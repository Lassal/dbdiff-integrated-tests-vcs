schema: SYS
name: STANDARD
routineType: PACKAGE
returnParamater:
  name: XOR.(--return--)
  dataType: PL/SQL BOOLEAN
  parameterMode: OUT
  ordinalPosition: 0
parameters:
- name: ' SYS$DSINTERVALSUBTRACT(1).LEFT'
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$DSINTERVALSUBTRACT(1).RIGHT'
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$DSINTERVALSUBTRACT(2).LEFT'
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$DSINTERVALSUBTRACT(2).RIGHT'
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$DSINTERVALSUBTRACT(3).LEFT'
  dataType: TIME
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$DSINTERVALSUBTRACT(3).RIGHT'
  dataType: TIME
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$DSINTERVALSUBTRACT(4).LEFT'
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$DSINTERVALSUBTRACT(4).RIGHT'
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$DSINTERVALSUBTRACT(5).LEFT'
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$DSINTERVALSUBTRACT(5).RIGHT'
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$DSINTERVALSUBTRACT(6).LEFT'
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$DSINTERVALSUBTRACT(6).RIGHT'
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$EXTRACT_FROM(1).T'
  dataType: TIME
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$EXTRACT_FROM(1).FIELD'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$EXTRACT_FROM(2).T'
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$EXTRACT_FROM(2).FIELD'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$EXTRACT_FROM(3).T'
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$EXTRACT_FROM(3).FIELD'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$EXTRACT_FROM(4).T'
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$EXTRACT_FROM(4).FIELD'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$EXTRACT_FROM(5).T'
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$EXTRACT_FROM(5).FIELD'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$EXTRACT_FROM(6).T'
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$EXTRACT_FROM(6).FIELD'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$EXTRACT_FROM(7).I'
  dataType: INTERVAL YEAR TO MONTH
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$EXTRACT_FROM(7).FIELD'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$EXTRACT_FROM(8).I'
  dataType: INTERVAL DAY TO SECOND
  numericPrecision: 9
  numericScale: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$EXTRACT_FROM(8).FIELD'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$EXTRACT_STRING_FROM(1).T'
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$EXTRACT_STRING_FROM(1).FIELD'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$EXTRACT_STRING_FROM(2).T'
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$EXTRACT_STRING_FROM(2).FIELD'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$EXTRACT_STRING_FROM(3).T'
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$EXTRACT_STRING_FROM(3).FIELD'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$STANDARD_CHR.N'
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$STANDARD_CHR.CSN'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$STANDARD_TRANSLATE.SRC'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$STANDARD_TRANSLATE.CSN'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$STANDARD_TRIM(1).V'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$STANDARD_TRIM(2).STR1'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$STANDARD_TRIM(2).TRFLAG'
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$STANDARD_TRIM(3).STR1'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$STANDARD_TRIM(3).TSET'
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$STANDARD_TRIM(3).TRFLAG'
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: ' SYS$STANDARD_TRIM(4).V'
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$STANDARD_TRIM(5).STR1'
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$STANDARD_TRIM(5).TRFLAG'
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$STANDARD_TRIM(6).STR1'
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$STANDARD_TRIM(6).TSET'
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$STANDARD_TRIM(6).TRFLAG'
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: ' SYS$YMINTERVALSUBTRACT(1).LEFT'
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$YMINTERVALSUBTRACT(1).RIGHT'
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$YMINTERVALSUBTRACT(2).LEFT'
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$YMINTERVALSUBTRACT(2).RIGHT'
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$YMINTERVALSUBTRACT(3).LEFT'
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$YMINTERVALSUBTRACT(3).RIGHT'
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 2
- name: ' SYS$YMINTERVALSUBTRACT(4).LEFT'
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: ' SYS$YMINTERVALSUBTRACT(4).RIGHT'
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: ABS(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: ABS(2).F
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: ABS(3).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: ABS(4).I
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 1
- name: ACOS(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: ACOS(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: ADD_MONTHS(1).LEFT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: ADD_MONTHS(1).RIGHT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 2
- name: ADD_MONTHS(2).LEFT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: ADD_MONTHS(2).RIGHT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 2
- name: ASCII.CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: ASCIISTR.CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: ASIN(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: ASIN(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: ATAN(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: ATAN(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: ATAN2(1).X
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: ATAN2(1).Y
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 2
- name: ATAN2(2).X
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: ATAN2(2).Y
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 2
- name: BFILENAME.DIRECTORY
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: BFILENAME.FILENAME
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: BITAND(1).LEFT
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 1
- name: BITAND(1).RIGHT
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: BITAND(2).LEFT
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 1
- name: BITAND(2).RIGHT
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 2
- name: CARDINALITY.COLLECTION
  dataType: TABLE
  parameterMode: IN
  ordinalPosition: 1
- name: CEIL(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: CEIL(2).F
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: CEIL(3).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: CHARTOROWID.STR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: CHR.N
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 1
- name: COMMIT_CM.VC
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: COMPOSE.CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: CONCAT(1).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: CONCAT(1).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: CONCAT(2).LEFT
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: CONCAT(2).RIGHT
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 2
- name: CONVERT(1).SRC
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: CONVERT(1).DESTCSET
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: CONVERT(2).SRC
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: CONVERT(2).DESTCSET
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: CONVERT(2).SRCCSET
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: CONVERT(3).SRCSTR
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: CONVERT(3).DSTCSN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: CONVERT(4).SRCSTR
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: CONVERT(4).DSTCSN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: CONVERT(4).SRCCSN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: COS(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: COS(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: COSH(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: COSH(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(1).EXPR
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(1).PAT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 2
- name: DECODE(1).RES
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 3
- name: DECODE(10).EXPR
  dataType: OBJECT
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(10).PAT
  dataType: OBJECT
  parameterMode: IN
  ordinalPosition: 2
- name: DECODE(10).RES
  dataType: OBJECT
  parameterMode: IN
  ordinalPosition: 3
- name: DECODE(11).EXPR
  dataType: OPAQUE/XMLTYPE
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(11).PAT
  dataType: OPAQUE/XMLTYPE
  parameterMode: IN
  ordinalPosition: 2
- name: DECODE(11).RES
  dataType: OPAQUE/XMLTYPE
  parameterMode: IN
  ordinalPosition: 3
- name: DECODE(2).EXPR
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(2).PAT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 2
- name: DECODE(2).RES
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: DECODE(3).EXPR
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(3).PAT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 2
- name: DECODE(3).RES
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 3
- name: DECODE(4).EXPR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(4).PAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: DECODE(4).RES
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 3
- name: DECODE(5).EXPR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(5).PAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: DECODE(5).RES
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: DECODE(6).EXPR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(6).PAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: DECODE(6).RES
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 3
- name: DECODE(7).EXPR
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(7).PAT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 2
- name: DECODE(7).RES
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 3
- name: DECODE(8).EXPR
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(8).PAT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 2
- name: DECODE(8).RES
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: DECODE(9).EXPR
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: DECODE(9).PAT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 2
- name: DECODE(9).RES
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 3
- name: DECOMPOSE.CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: DECOMPOSE.CANMODE
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: DEREF.R
  dataType: REF
  parameterMode: IN
  ordinalPosition: 1
- name: DUMP(1).E
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: DUMP(1).DF
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: DUMP(1).SP
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: DUMP(1).LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 4
- name: DUMP(2).E
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: DUMP(2).DF
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: DUMP(2).SP
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: DUMP(2).LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 4
- name: DUMP(3).E
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: DUMP(3).DF
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: DUMP(3).SP
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: DUMP(3).LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 4
- name: EXP(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: EXP(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: FLOOR(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: FLOOR(2).F
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: FLOOR(3).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: FROM_TZ.T
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: FROM_TZ.TIMEZONE
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: GLB.LABEL
  dataType: MLSLABEL
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(1).PATTERN
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(10).PATTERN
  dataType: INTERVAL DAY TO SECOND
  numericPrecision: 9
  numericScale: 9
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(11).PATTERN
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(12).PATTERN
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(13).PATTERN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(2).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(3).PATTERN
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(4).PATTERN
  dataType: TIME
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(5).PATTERN
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(6).PATTERN
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(7).PATTERN
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(8).PATTERN
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST(9).PATTERN
  dataType: INTERVAL YEAR TO MONTH
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: GREATEST_LB.PATTERN
  dataType: MLSLABEL
  parameterMode: IN
  ordinalPosition: 1
- name: GROUPING(1).V
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: GROUPING(2).A
  dataType: OBJECT
  parameterMode: IN
  ordinalPosition: 1
- name: GROUPING(3).A
  dataType: OPAQUE/XMLTYPE
  parameterMode: IN
  ordinalPosition: 1
- name: HEXTORAW.C
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: INITCAP.CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: INSTR(1).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: INSTR(1).STR2
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: INSTR(1).POS
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: INSTR(1).NTH
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 4
- name: INSTR(2).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: INSTR(2).STR2
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 2
- name: INSTR(2).POS
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 3
- name: INSTR(2).NTH
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 4
- name: INSTR2.STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: INSTR2.STR2
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: INSTR2.POS
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: INSTR2.NTH
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 4
- name: INSTR4.STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: INSTR4.STR2
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: INSTR4.POS
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: INSTR4.NTH
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 4
- name: INSTRB(1).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: INSTRB(1).STR2
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: INSTRB(1).POS
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: INSTRB(1).NTH
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 4
- name: INSTRB(2).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: INSTRB(2).STR2
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 2
- name: INSTRB(2).POS
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 3
- name: INSTRB(2).NTH
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 4
- name: INSTRC.STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: INSTRC.STR2
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: INSTRC.POS
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: INSTRC.NTH
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 4
- name: ISNCHAR.C
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LAST_DAY.RIGHT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(1).PATTERN
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(10).PATTERN
  dataType: INTERVAL DAY TO SECOND
  numericPrecision: 9
  numericScale: 9
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(11).PATTERN
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(12).PATTERN
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(13).PATTERN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(2).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(3).PATTERN
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(4).PATTERN
  dataType: TIME
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(5).PATTERN
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(6).PATTERN
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(7).PATTERN
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(8).PATTERN
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST(9).PATTERN
  dataType: INTERVAL YEAR TO MONTH
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: LEAST_UB.PATTERN
  dataType: MLSLABEL
  parameterMode: IN
  ordinalPosition: 1
- name: LENGTH(1).CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LENGTH(2).CH
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: LENGTH(3).BL
  dataType: BLOB
  parameterMode: IN
  ordinalPosition: 1
- name: LENGTH2.CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LENGTH4.CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LENGTHB(1).CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LENGTHB(2).CH
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: LENGTHB(3).BL
  dataType: BLOB
  parameterMode: IN
  ordinalPosition: 1
- name: LENGTHC.CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LN(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: LN(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: LOG(1).LEFT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: LOG(1).RIGHT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 2
- name: LOG(2).LEFT
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: LOG(2).RIGHT
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 2
- name: LOWER(1).CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LOWER(2).CH
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: LPAD(1).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LPAD(1).LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: LPAD(1).PAD
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: LPAD(2).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LPAD(2).LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: LPAD(3).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: LPAD(3).LEN
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 2
- name: LPAD(3).PAD
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 3
- name: LPAD(4).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: LPAD(4).LEN
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 2
- name: LTRIM(1).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LTRIM(1).TSET
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: LTRIM(2).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: LTRIM(3).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: LTRIM(3).TSET
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 2
- name: LTRIM(4).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: LUB.LABEL
  dataType: MLSLABEL
  parameterMode: IN
  ordinalPosition: 1
- name: MONTHS_BETWEEN.LEFT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: MONTHS_BETWEEN.RIGHT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 2
- name: NANVL(1).N1
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: NANVL(1).N2
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 2
- name: NANVL(2).F1
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: NANVL(2).F2
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 2
- name: NANVL(3).D1
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: NANVL(3).D2
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 2
- name: NCHARTOROWID.STR
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NCHR.N
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 1
- name: NEW_TIME.RIGHT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: NEW_TIME.MIDDLE
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NEW_TIME.LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: NEXT_DAY.LEFT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: NEXT_DAY.RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NHEXTORAW.C
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NLSSORT(1).C
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NLSSORT(2).C
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NLSSORT(2).C2
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NLS_CHARSET_DECL_LEN.BYTECNT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_CHARSET_DECL_LEN.CSETID
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 2
- name: NLS_CHARSET_ID.CSETNAME
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_CHARSET_NAME.CSETID
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_INITCAP(1).CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_INITCAP(1).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NLS_INITCAP(2).CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_LOWER(1).CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_LOWER(1).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NLS_LOWER(2).CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_LOWER(3).CH
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_LOWER(3).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NLS_LOWER(4).CH
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_UPPER(1).CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_UPPER(1).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NLS_UPPER(2).CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_UPPER(3).CH
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: NLS_UPPER(3).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NLS_UPPER(4).CH
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: NULLFN.STR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NULLIF(1).V1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NULLIF(1).V2
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NULLIF(2).V1
  dataType: PL/SQL BOOLEAN
  parameterMode: IN
  ordinalPosition: 1
- name: NULLIF(2).V2
  dataType: PL/SQL BOOLEAN
  parameterMode: IN
  ordinalPosition: 2
- name: NULLIF(3).A1
  dataType: OBJECT
  parameterMode: IN
  ordinalPosition: 1
- name: NULLIF(3).A2
  dataType: OBJECT
  parameterMode: IN
  ordinalPosition: 2
- name: NULLIF(4).A1
  dataType: OPAQUE/XMLTYPE
  parameterMode: IN
  ordinalPosition: 1
- name: NULLIF(4).A2
  dataType: OPAQUE/XMLTYPE
  parameterMode: IN
  ordinalPosition: 2
- name: NUMTODSINTERVAL.NUMERATOR
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: NUMTODSINTERVAL.UNITS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NUMTOYMINTERVAL.NUMERATOR
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: NUMTOYMINTERVAL.UNITS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(1).B1
  dataType: PL/SQL BOOLEAN
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(1).B2
  dataType: PL/SQL BOOLEAN
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(10).B1
  dataType: TIME
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(10).B2
  dataType: TIME
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(11).B1
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(11).B2
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(12).B1
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(12).B2
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(13).B1
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(13).B2
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(14).B1
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(14).B2
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(15).B1
  dataType: INTERVAL YEAR TO MONTH
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(15).B2
  dataType: INTERVAL YEAR TO MONTH
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(16).B1
  dataType: INTERVAL DAY TO SECOND
  numericPrecision: 9
  numericScale: 9
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(16).B2
  dataType: INTERVAL DAY TO SECOND
  numericPrecision: 9
  numericScale: 9
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(17).S1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(17).S2
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(18).B1
  dataType: OPAQUE/XMLTYPE
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(18).B2
  dataType: OPAQUE/XMLTYPE
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(19).F1
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(19).F2
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(2).S1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(2).S2
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(20).D1
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(20).D2
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(21).I1
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(21).I2
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(3).N1
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(3).N2
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(4).D1
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(4).D2
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(5).LABEL1
  dataType: MLSLABEL
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(5).LABEL2
  dataType: MLSLABEL
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(6).B1
  dataType: OBJECT
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(6).B2
  dataType: OBJECT
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(7).B1
  dataType: REF
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(7).B2
  dataType: REF
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(8).B1
  dataType: TABLE
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(8).B2
  dataType: TABLE
  parameterMode: IN
  ordinalPosition: 2
- name: NVL(9).B1
  dataType: REF CURSOR
  parameterMode: IN
  ordinalPosition: 1
- name: NVL(9).B2
  dataType: REF CURSOR
  parameterMode: IN
  ordinalPosition: 2
- name: POWER(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: POWER(1).E
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 2
- name: POWER(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: POWER(2).E
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 2
- name: RAWTOHEX.R
  dataType: RAW
  parameterMode: IN
  ordinalPosition: 1
- name: RAWTONHEX.R
  dataType: RAW
  parameterMode: IN
  ordinalPosition: 1
- name: REF.ITEM
  dataType: TABLE
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_COUNT(1).SRCSTR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_COUNT(1).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REGEXP_COUNT(1).POSITION
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: REGEXP_COUNT(1).MODIFIER
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 4
- name: REGEXP_COUNT(2).SRCSTR
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_COUNT(2).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REGEXP_COUNT(2).POSITION
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 3
- name: REGEXP_COUNT(2).MODIFIER
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 4
- name: REGEXP_INSTR(1).SRCSTR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_INSTR(1).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REGEXP_INSTR(1).POSITION
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: REGEXP_INSTR(1).OCCURRENCE
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 4
- name: REGEXP_INSTR(1).RETURNPARAM
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 5
- name: REGEXP_INSTR(1).MODIFIER
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 6
- name: REGEXP_INSTR(1).SUBEXPRESSION
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 7
- name: REGEXP_INSTR(2).SRCSTR
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_INSTR(2).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REGEXP_INSTR(2).POSITION
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 3
- name: REGEXP_INSTR(2).OCCURRENCE
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 4
- name: REGEXP_INSTR(2).RETURNPARAM
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 5
- name: REGEXP_INSTR(2).MODIFIER
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 6
- name: REGEXP_INSTR(2).SUBEXPRESSION
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 7
- name: REGEXP_LIKE(1).SRCSTR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_LIKE(1).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REGEXP_LIKE(1).MODIFIER
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: REGEXP_LIKE(2).SRCSTR
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_LIKE(2).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REGEXP_LIKE(2).MODIFIER
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: REGEXP_REPLACE(1).SRCSTR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_REPLACE(1).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REGEXP_REPLACE(1).REPLACESTR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: REGEXP_REPLACE(1).POSITION
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 4
- name: REGEXP_REPLACE(1).OCCURRENCE
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 5
- name: REGEXP_REPLACE(1).MODIFIER
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 6
- name: REGEXP_REPLACE(2).SRCSTR
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_REPLACE(2).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REGEXP_REPLACE(2).REPLACESTR
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 3
- name: REGEXP_REPLACE(2).POSITION
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 4
- name: REGEXP_REPLACE(2).OCCURRENCE
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 5
- name: REGEXP_REPLACE(2).MODIFIER
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 6
- name: REGEXP_REPLACE(3).SRCSTR
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_REPLACE(3).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REGEXP_REPLACE(3).REPLACESTR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: REGEXP_REPLACE(3).POSITION
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 4
- name: REGEXP_REPLACE(3).OCCURRENCE
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 5
- name: REGEXP_REPLACE(3).MODIFIER
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 6
- name: REGEXP_SUBSTR(1).SRCSTR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_SUBSTR(1).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REGEXP_SUBSTR(1).POSITION
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: REGEXP_SUBSTR(1).OCCURRENCE
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 4
- name: REGEXP_SUBSTR(1).MODIFIER
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 5
- name: REGEXP_SUBSTR(1).SUBEXPRESSION
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 6
- name: REGEXP_SUBSTR(2).SRCSTR
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: REGEXP_SUBSTR(2).PATTERN
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REGEXP_SUBSTR(2).POSITION
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 3
- name: REGEXP_SUBSTR(2).OCCURRENCE
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 4
- name: REGEXP_SUBSTR(2).MODIFIER
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 5
- name: REGEXP_SUBSTR(2).SUBEXPRESSION
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 6
- name: REMAINDER(1).N1
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: REMAINDER(1).N2
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 2
- name: REMAINDER(2).F1
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: REMAINDER(2).F2
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 2
- name: REMAINDER(3).D1
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: REMAINDER(3).D2
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 2
- name: REPLACE(1).SRCSTR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: REPLACE(1).OLDSUB
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: REPLACE(1).NEWSUB
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: REPLACE(2).SRCSTR
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: REPLACE(2).OLDSUB
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 2
- name: REPLACE(2).NEWSUB
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 3
- name: ROLLBACK_SV.SAVE_POINT
  dataType: CHAR
  parameterMode: IN
  ordinalPosition: 1
- name: ROUND(1).LEFT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: ROUND(1).RIGHT
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: ROUND(2).RIGHT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: ROUND(3).LEFT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: ROUND(3).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: ROUND(4).LEFT
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: ROUND(5).LEFT
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: ROUND(6).I
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 1
- name: ROUND(6).PLACES
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: ROWIDTOCHAR.STR
  dataType: ROWID
  parameterMode: IN
  ordinalPosition: 1
- name: ROWIDTONCHAR.STR
  dataType: ROWID
  parameterMode: IN
  ordinalPosition: 1
- name: RPAD(1).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: RPAD(1).LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: RPAD(1).PAD
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: RPAD(2).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: RPAD(2).LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: RPAD(3).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: RPAD(3).LEN
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 2
- name: RPAD(3).PAD
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 3
- name: RPAD(4).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: RPAD(4).LEN
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 2
- name: RTRIM(1).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: RTRIM(1).TSET
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: RTRIM(2).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: RTRIM(3).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: RTRIM(3).TSET
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 2
- name: RTRIM(4).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: SAVEPOINT.SAVE_POINT
  dataType: CHAR
  parameterMode: IN
  ordinalPosition: 1
- name: SET.COLLECTION
  dataType: TABLE
  parameterMode: IN
  ordinalPosition: 1
- name: SET_TRANSACTION_USE.VC
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SIGN(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: SIGN(2).F
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: SIGN(3).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: SIGN(4).I
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 1
- name: SIN(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: SIN(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: SINH(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: SINH(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: SOUNDEX.CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SQLERRM(2).CODE
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 1
- name: SQRT(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: SQRT(2).F
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: SQRT(3).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: SUBSTR(1).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SUBSTR(1).POS
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: SUBSTR(1).LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: SUBSTR(2).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: SUBSTR(2).POS
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 2
- name: SUBSTR(2).LEN
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 3
- name: SUBSTR2.STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SUBSTR2.POS
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: SUBSTR2.LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: SUBSTR4.STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SUBSTR4.POS
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: SUBSTR4.LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: SUBSTRB(1).STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SUBSTRB(1).POS
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: SUBSTRB(1).LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: SUBSTRB(2).STR1
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: SUBSTRB(2).POS
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 2
- name: SUBSTRB(2).LEN
  dataType: NUMBER
  numericPrecision: 38
  parameterMode: IN
  ordinalPosition: 3
- name: SUBSTRC.STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SUBSTRC.POS
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: SUBSTRC.LEN
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 3
- name: SYS$LOB_REPLICATION(1).X
  dataType: BLOB
  parameterMode: IN
  ordinalPosition: 1
- name: SYS$LOB_REPLICATION(2).X
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_AT_TIME_ZONE(1).T
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_AT_TIME_ZONE(1).I
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: SYS_AT_TIME_ZONE(2).T
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_AT_TIME_ZONE(2).I
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: SYS_CONTEXT(1).NAMESPACE
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_CONTEXT(1).ATTRIBUTE
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: SYS_CONTEXT(2).NAMESPACE
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_CONTEXT(2).ATTRIBUTE
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: SYS_CONTEXT(2).NEWOPTIONAL
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: SYS_EXTRACT_UTC.T
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_LITERALTODATE.NUMERATOR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_LITERALTODSINTERVAL.NUMERATOR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_LITERALTODSINTERVAL.UNITS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: SYS_LITERALTOTIME.NUMERATOR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_LITERALTOTIMESTAMP.NUMERATOR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_LITERALTOTZTIME.NUMERATOR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_LITERALTOTZTIMESTAMP.NUMERATOR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_LITERALTOYMINTERVAL.NUMERATOR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: SYS_LITERALTOYMINTERVAL.UNITS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TAN(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: TAN(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: TANH(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: TANH(2).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_ANYLOB.RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_BINARY_DOUBLE(1).RIGHT
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_BINARY_DOUBLE(2).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_BINARY_DOUBLE(2).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_BINARY_DOUBLE(3).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_BINARY_DOUBLE(3).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_BINARY_DOUBLE(3).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_BINARY_FLOAT(1).RIGHT
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: TO_BINARY_FLOAT(2).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_BINARY_FLOAT(2).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_BINARY_FLOAT(3).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_BINARY_FLOAT(3).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_BINARY_FLOAT(3).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_BLOB.RIGHT
  dataType: RAW
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(1).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(10).LEFT
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(10).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(11).LEFT
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(11).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(11).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_CHAR(12).LEFT
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(12).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(13).LEFT
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(13).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(13).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_CHAR(14).LEFT
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(14).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(15).LEFT
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(15).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(15).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_CHAR(16).LEFT
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(16).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(17).LEFT
  dataType: INTERVAL YEAR TO MONTH
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(17).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(17).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_CHAR(18).LEFT
  dataType: INTERVAL YEAR TO MONTH
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(18).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(19).LEFT
  dataType: INTERVAL DAY TO SECOND
  numericPrecision: 9
  numericScale: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(19).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(19).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_CHAR(2).LEFT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(2).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(20).LEFT
  dataType: INTERVAL DAY TO SECOND
  numericPrecision: 9
  numericScale: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(20).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(21).LEFT
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(21).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(22).LEFT
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(22).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(23).LEFT
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(23).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(23).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_CHAR(24).LEFT
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(24).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(24).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_CHAR(3).LEFT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(3).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(4).LABEL
  dataType: MLSLABEL
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(4).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(5).LEFT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(5).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(5).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_CHAR(6).LEFT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(6).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(6).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_CHAR(7).LEFT
  dataType: TIME
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(7).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(7).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_CHAR(8).LEFT
  dataType: TIME
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(8).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(9).LEFT
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CHAR(9).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_CHAR(9).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_CLOB(1).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_CLOB(2).CL
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: TO_DATE(1).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_DATE(2).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_DATE(2).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_DATE(3).LEFT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: TO_DATE(3).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_DATE(4).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_DATE(4).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_DATE(4).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_DSINTERVAL(1).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_DSINTERVAL(2).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_DSINTERVAL(2).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_LABEL(1).LABEL
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_LABEL(1).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_LABEL(2).LABEL
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_MULTI_BYTE.C
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NCHAR(1).RIGHT
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NCHAR(2).LEFT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NCHAR(2).FORMAT
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_NCHAR(3).LEFT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NCHAR(3).FORMAT
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_NCHAR(4).LEFT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NCHAR(4).FORMAT
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_NCHAR(4).PARMS
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_NCHAR(5).LEFT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NCHAR(5).FORMAT
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_NCHAR(5).PARMS
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_NCHAR(6).LEFT
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NCHAR(6).FORMAT
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_NCHAR(7).LEFT
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NCHAR(7).FORMAT
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_NCHAR(8).LEFT
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NCHAR(8).FORMAT
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_NCHAR(8).PARMS
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_NCHAR(9).LEFT
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NCHAR(9).FORMAT
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_NCHAR(9).PARMS
  dataType: NVARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_NCLOB(1).CL
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NCLOB(2).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NUMBER(1).RIGHT
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NUMBER(2).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NUMBER(3).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NUMBER(3).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_NUMBER(4).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_NUMBER(4).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_NUMBER(4).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_RAW.RIGHT
  dataType: BLOB
  parameterMode: IN
  ordinalPosition: 1
- name: TO_SINGLE_BYTE.C
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIME(1).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIME(2).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIME(2).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_TIME(2).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_TIME(3).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIME(3).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_TIME(4).RIGHT
  dataType: TIME WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP(1).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP(2).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP(2).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_TIMESTAMP(2).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_TIMESTAMP(3).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP(3).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_TIMESTAMP(4).RIGHT
  dataType: TIMESTAMP WITH TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP(5).RIGHT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP(6).ARG
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP_TZ(1).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP_TZ(2).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP_TZ(2).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_TIMESTAMP_TZ(2).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_TIMESTAMP_TZ(3).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP_TZ(3).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_TIMESTAMP_TZ(4).RIGHT
  dataType: TIMESTAMP
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP_TZ(5).ARG
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIMESTAMP_TZ(6).ARG
  dataType: TIMESTAMP WITH LOCAL TIME ZONE
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIME_TZ(1).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIME_TZ(2).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIME_TZ(2).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_TIME_TZ(2).PARMS
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TO_TIME_TZ(3).LEFT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TO_TIME_TZ(3).FORMAT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TO_TIME_TZ(4).RIGHT
  dataType: TIME
  numericPrecision: 9
  parameterMode: IN
  ordinalPosition: 1
- name: TO_YMINTERVAL.RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TRANSLATE.STR1
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TRANSLATE.SRC
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TRANSLATE.DEST
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 3
- name: TRIM(1).V
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: TRIM(2).V
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: TRUNC(1).N
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: TRUNC(1).PLACES
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: TRUNC(2).LEFT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: TRUNC(3).LEFT
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: TRUNC(3).RIGHT
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 2
- name: TRUNC(4).F
  dataType: BINARY_FLOAT
  parameterMode: IN
  ordinalPosition: 1
- name: TRUNC(5).D
  dataType: BINARY_DOUBLE
  parameterMode: IN
  ordinalPosition: 1
- name: TRUNC(6).I
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 1
- name: TRUNC(6).PLACES
  dataType: BINARY_INTEGER
  parameterMode: IN
  ordinalPosition: 2
- name: TZ_OFFSET.REGION
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: UNISTR.CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: UPPER(1).CH
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: UPPER(2).CH
  dataType: CLOB
  parameterMode: IN
  ordinalPosition: 1
- name: USERENV.ENVSTR
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: VALUE.ITEM
  dataType: TABLE
  parameterMode: IN
  ordinalPosition: 1
- name: VSIZE(1).E
  dataType: NUMBER
  parameterMode: IN
  ordinalPosition: 1
- name: VSIZE(2).E
  dataType: DATE
  parameterMode: IN
  ordinalPosition: 1
- name: VSIZE(3).E
  dataType: VARCHAR2
  parameterMode: IN
  ordinalPosition: 1
- name: XOR.LEFT
  dataType: PL/SQL BOOLEAN
  parameterMode: IN
  ordinalPosition: 1
- name: XOR.RIGHT
  dataType: PL/SQL BOOLEAN
  parameterMode: IN
  ordinalPosition: 2
routineDefinition: "package STANDARD AUTHID CURRENT_USER is -- careful on this line;\
  \ SED edit occurs!\n/********** Types and subtypes, do not reorder **********/\n\
  type BOOLEAN is (FALSE, TRUE);\ntype DATE is DATE_BASE;\ntype NUMBER is NUMBER_BASE;\n\
  subtype FLOAT is NUMBER;\n-- NUMBER(126)\nsubtype REAL is FLOAT;\n-- FLOAT(63)\n\
  subtype \"DOUBLE PRECISION\" is FLOAT;\nsubtype INTEGER is NUMBER(38, 0);\nsubtype\
  \ INT is INTEGER;\nsubtype SMALLINT is NUMBER(38, 0);\nsubtype DECIMAL is NUMBER(38,\
  \ 0);\nsubtype NUMERIC is DECIMAL;\nsubtype DEC is DECIMAL;\nsubtype BINARY_INTEGER\
  \ is INTEGER range '-2147483647' ..2147483647;\nsubtype NATURAL is BINARY_INTEGER\
  \ range 0 ..2147483647;\nsubtype NATURALN is NATURAL not null;\nsubtype POSITIVE\
  \ is BINARY_INTEGER range 1 ..2147483647;\nsubtype POSITIVEN is POSITIVE not null;\n\
  subtype SIGNTYPE is BINARY_INTEGER range '-1' ..1;\n-- for SIGN functions\ntype\
  \ VARCHAR2 is NEW CHAR_BASE;\nsubtype VARCHAR is VARCHAR2;\nsubtype STRING is VARCHAR2;\n\
  subtype LONG is VARCHAR2(32760);\nsubtype RAW is VARCHAR2;\nsubtype \"LONG RAW\"\
  \ is RAW(32760);\nsubtype ROWID is VARCHAR2(256);\n-- Ansi fixed-length char\n--\
  \ Define synonyms for CHAR and CHARN.\nsubtype CHAR is VARCHAR2;\nsubtype CHARACTER\
  \ is CHAR;\ntype MLSLABEL is new CHAR_BASE;\n-- Large object data types.\n--  binary,\
  \ character, binary file.\ntype BLOB is BLOB_BASE;\ntype CLOB is CLOB_BASE;\ntype\
  \ BFILE is BFILE_BASE;\n-- Verbose and NCHAR type names\nsubtype \"CHARACTER VARYING\"\
  \ is VARCHAR;\nsubtype \"CHAR VARYING\" is VARCHAR;\nsubtype \"NATIONAL CHARACTER\"\
  \ is CHAR CHARACTER\nSET\n  NCHAR_CS;\nsubtype \"NATIONAL CHAR\" is CHAR CHARACTER\n\
  SET\n  NCHAR_CS;\nsubtype \"NCHAR\" is CHAR CHARACTER\nSET\n  NCHAR_CS;\nsubtype\
  \ \"NATIONAL CHARACTER VARYING\" is VARCHAR CHARACTER\nSET\n  NCHAR_CS;\nsubtype\
  \ \"NATIONAL CHAR VARYING\" is VARCHAR CHARACTER\nSET\n  NCHAR_CS;\nsubtype \"NCHAR\
  \ VARYING\" is VARCHAR CHARACTER\nSET\n  NCHAR_CS;\nsubtype \"NVARCHAR2\" is VARCHAR2\
  \ CHARACTER\nSET\n  NCHAR_CS;\nsubtype \"CHARACTER LARGE OBJECT\" is CLOB;\nsubtype\
  \ \"CHAR LARGE OBJECT\" is CLOB;\nsubtype \"NATIONAL CHARACTER LARGE OBJEC\" is\
  \ CLOB CHARACTER\nSET\n  NCHAR_CS;\nsubtype \"NCHAR LARGE OBJECT\" is CLOB CHARACTER\n\
  SET\n  NCHAR_CS;\nsubtype \"NCLOB\" is CLOB CHARACTER\nSET\n  NCHAR_CS;\nsubtype\
  \ \"BINARY LARGE OBJECT\" is BLOB;\nsubtype pls_integer is binary_integer;\ntype\
  \ TIME is new DATE_BASE;\ntype TIMESTAMP is new DATE_BASE;\ntype \"TIME WITH TIME\
  \ ZONE\" is new DATE_BASE;\ntype \"TIMESTAMP WITH TIME ZONE\" is new DATE_BASE;\n\
  type \"INTERVAL YEAR TO MONTH\" is new DATE_BASE;\ntype \"INTERVAL DAY TO SECOND\"\
  \ is new DATE_BASE;\nSUBTYPE TIME_UNCONSTRAINED IS TIME(9);\nSUBTYPE TIME_TZ_UNCONSTRAINED\
  \ IS TIME(9) WITH TIME ZONE;\nSUBTYPE TIMESTAMP_UNCONSTRAINED IS TIMESTAMP(9);\n\
  SUBTYPE TIMESTAMP_TZ_UNCONSTRAINED IS TIMESTAMP(9) WITH TIME ZONE;\nSUBTYPE YMINTERVAL_UNCONSTRAINED\
  \ IS INTERVAL YEAR(9) TO MONTH;\nSUBTYPE DSINTERVAL_UNCONSTRAINED IS INTERVAL DAY(9)\
  \ TO SECOND (9);\nTYPE UROWID IS NEW CHAR_BASE;\ntype \"TIMESTAMP WITH LOCAL TIME\
  \ ZONE\" is new DATE_BASE;\nsubtype timestamp_ltz_unconstrained is timestamp(9)\
  \ with local time zone;\nsubtype BINARY_FLOAT is NUMBER;\nsubtype BINARY_DOUBLE\
  \ is NUMBER;\n-- The following data types are generics, used specially within package\n\
  \  -- STANDARD and some other Oracle packages.  They are protected against\n  --\
  \ other use; sorry.  True generic types are not yet part of the language.\n  type\
  \ \"<ADT_1>\" as object (dummy char(1));\ntype \"<RECORD_1>\" is record (dummy char(1));\n\
  type \"<TUPLE_1>\" as object (dummy char(1));\ntype \"<VARRAY_1>\" is varray (1)\
  \ of char(1);\ntype \"<V2_TABLE_1>\" is table of char(1) index by binary_integer;\n\
  type \"<TABLE_1>\" is table of char(1);\ntype \"<COLLECTION_1>\" is table of char(1);\n\
  type \"<REF_CURSOR_1>\" is ref cursor;\n-- This will actually match against a Q_TABLE\n\
  \  type \"<TYPED_TABLE>\" is table of \"<ADT_1>\";\nsubtype \"<ADT_WITH_OID>\" is\
  \ \"<TYPED_TABLE>\";\n-- The following generic index table data types are used by\
  \ the PL/SQL\n  -- compiler to materialize an array attribute at the runtime (for\
  \ more\n  -- details about the array attributes, please see Bulk Binds document).\n\
  \  type \" SYS$INT_V2TABLE\" is table of integer index by binary_integer;\n-- The\
  \ following record type and the corresponding generic index table\n  -- data types\
  \ are used by the PL/SQL compiler to materialize a table\n  -- at the runtime in\
  \ order to record the exceptions raised during the\n  -- execution of FORALL bulk\
  \ bind statement (for more details, please\n  -- see bulk binds extensions document\
  \ in 8.2).\n  type \" SYS$BULK_ERROR_RECORD\" is record (error_index pls_integer,\
  \ error_code pls_integer);\ntype \" SYS$REC_V2TABLE\" is table of \" SYS$BULK_ERROR_RECORD\"\
  \ index by binary_integer;\n  /* Adding a generic weak ref cursor type */\n  type\
  \ sys_refcursor is ref cursor;\n  /* the following data type is a generic for all\
  \ opaque types */\n  type \"<OPAQUE_1>\" as opaque FIXED(1) USING LIBRARY dummy_lib\
  \ (static function dummy return number);\ntype \"<ASSOC_ARRAY_1>\" is table of char(1)\
  \ index by varchar2(1);\n  /********** Add new types or subtypes here **********/\n\
  \  -- Simple scalar types\n  subtype SIMPLE_INTEGER is BINARY_INTEGER NOT NULL;\n\
  subtype SIMPLE_FLOAT is BINARY_FLOAT NOT NULL;\nsubtype SIMPLE_DOUBLE is BINARY_DOUBLE\
  \ NOT NULL;\n  /********** Predefined constants **********/\n  BINARY_FLOAT_NAN\
  \ constant BINARY_FLOAT;\nBINARY_FLOAT_INFINITY constant BINARY_FLOAT;\nBINARY_FLOAT_MAX_NORMAL\
  \ constant BINARY_FLOAT;\nBINARY_FLOAT_MIN_NORMAL constant BINARY_FLOAT;\nBINARY_FLOAT_MAX_SUBNORMAL\
  \ constant BINARY_FLOAT;\nBINARY_FLOAT_MIN_SUBNORMAL constant BINARY_FLOAT;\nBINARY_DOUBLE_NAN\
  \ constant BINARY_DOUBLE;\nBINARY_DOUBLE_INFINITY constant BINARY_DOUBLE;\nBINARY_DOUBLE_MAX_NORMAL\
  \ constant BINARY_DOUBLE;\nBINARY_DOUBLE_MIN_NORMAL constant BINARY_DOUBLE;\nBINARY_DOUBLE_MAX_SUBNORMAL\
  \ constant BINARY_DOUBLE;\nBINARY_DOUBLE_MIN_SUBNORMAL constant BINARY_DOUBLE;\n\
  \  /********** Add new constants here **********/\n  /********** Predefined exceptions\
  \ **********/\n  CURSOR_ALREADY_OPEN\nexception;\npragma EXCEPTION_INIT(CURSOR_ALREADY_OPEN,\
  \ '-6511');\nDUP_VAL_ON_INDEX\nexception;\npragma EXCEPTION_INIT(DUP_VAL_ON_INDEX,\
  \ '-0001');\nTIMEOUT_ON_RESOURCE\nexception;\npragma EXCEPTION_INIT(TIMEOUT_ON_RESOURCE,\
  \ '-0051');\nINVALID_CURSOR\nexception;\npragma EXCEPTION_INIT(INVALID_CURSOR, '-1001');\n\
  NOT_LOGGED_ON\nexception;\npragma EXCEPTION_INIT(NOT_LOGGED_ON, '-1012');\nLOGIN_DENIED\n\
  exception;\npragma EXCEPTION_INIT(LOGIN_DENIED, '-1017');\nNO_DATA_FOUND\nexception;\n\
  pragma EXCEPTION_INIT(NO_DATA_FOUND, 100);\nZERO_DIVIDE\nexception;\npragma EXCEPTION_INIT(ZERO_DIVIDE,\
  \ '-1476');\nINVALID_NUMBER\nexception;\npragma EXCEPTION_INIT(INVALID_NUMBER, '-1722');\n\
  TOO_MANY_ROWS\nexception;\npragma EXCEPTION_INIT(TOO_MANY_ROWS, '-1422');\nSTORAGE_ERROR\n\
  exception;\npragma EXCEPTION_INIT(STORAGE_ERROR, '-6500');\nPROGRAM_ERROR\nexception;\n\
  pragma EXCEPTION_INIT(PROGRAM_ERROR, '-6501');\nVALUE_ERROR\nexception;\npragma\
  \ EXCEPTION_INIT(VALUE_ERROR, '-6502');\nACCESS_INTO_NULL\nexception;\npragma EXCEPTION_INIT(ACCESS_INTO_NULL,\
  \ '-6530');\nCOLLECTION_IS_NULL\nexception;\npragma EXCEPTION_INIT(COLLECTION_IS_NULL,\
  \ '-6531');\nSUBSCRIPT_OUTSIDE_LIMIT\nexception;\npragma EXCEPTION_INIT(SUBSCRIPT_OUTSIDE_LIMIT,\
  \ '-6532');\nSUBSCRIPT_BEYOND_COUNT\nexception;\npragma EXCEPTION_INIT(SUBSCRIPT_BEYOND_COUNT,\
  \ '-6533');\n-- exception for ref cursors\n  ROWTYPE_MISMATCH\nexception;\npragma\
  \ EXCEPTION_INIT(ROWTYPE_MISMATCH, '-6504');\nSYS_INVALID_ROWID\nEXCEPTION;\nPRAGMA\
  \ EXCEPTION_INIT(SYS_INVALID_ROWID, '-1410');\n-- The object instance i.e. SELF\
  \ is null\n  SELF_IS_NULL\nexception;\npragma EXCEPTION_INIT(SELF_IS_NULL, '-30625');\n\
  CASE_NOT_FOUND\nexception;\npragma EXCEPTION_INIT(CASE_NOT_FOUND, '-6592');\n--\
  \ Added for USERENV enhancement, bug 1622213.\n  USERENV_COMMITSCN_ERROR\nexception;\n\
  pragma EXCEPTION_INIT(USERENV_COMMITSCN_ERROR, '-1725');\n-- Parallel and pipelined\
  \ support\n  NO_DATA_NEEDED\nexception;\npragma EXCEPTION_INIT(NO_DATA_NEEDED, '-6548');\n\
  -- End of 8.2 parallel and pipelined support\n  /********** Add new exceptions here\
  \ **********/\n  /********** Function, operators and procedures **********/\n  function\
  \ \"EXISTS\" return BOOLEAN;\npragma BUILTIN('EXISTS', 10, 240, 240);\n-- This is\
  \ special cased in PH2 -- Pj\n  function GREATEST (pattern NUMBER) return NUMBER;\n\
  pragma BUILTIN('GREATEST', 12, 240, 240);\n-- This is special cased in PH2 -- Pj\n\
  \  function GREATEST (\n    pattern VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n\
  \  ) return VARCHAR2 CHARACTER\nSET\n  pattern % CHARSET;\npragma BUILTIN('GREATEST',\
  \ 12, 240, 240);\n-- This is special cased in PH2 -- Pj\n  function GREATEST (pattern\
  \ DATE) return DATE;\npragma BUILTIN('GREATEST', 12, 240, 240);\n-- This is special\
  \ cased in PH2 -- Pj\n  function LEAST (pattern NUMBER) return NUMBER;\npragma BUILTIN('LEAST',\
  \ 13, 240, 240);\n-- This is special cased in PH2 -- Pj\n  function LEAST (\n  \
  \  pattern VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\n\
  SET\n  pattern % CHARSET;\npragma BUILTIN('LEAST', 13, 240, 240);\n-- This is special\
  \ cased in PH2 -- Pj\n  function LEAST (pattern DATE) return DATE;\npragma BUILTIN('LEAST',\
  \ 13, 240, 240);\n-- This is special cased in PH2 -- Pj\n  function DECODE (expr\
  \ NUMBER, pat NUMBER, res NUMBER) return NUMBER;\npragma BUILTIN('DECODE', 22, 240,\
  \ 240);\n-- This is special cased in PH2 -- Pj\n  function DECODE (\n    expr NUMBER,\n\
  \    pat NUMBER,\n    res VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return\
  \ VARCHAR2 CHARACTER\nSET\n  res % CHARSET;\npragma BUILTIN('DECODE', 22, 240, 240);\n\
  -- This is special cased in PH2 -- Pj\n  function DECODE (expr NUMBER, pat NUMBER,\
  \ res DATE) return DATE;\npragma BUILTIN('DECODE', 22, 240, 240);\n-- This is special\
  \ cased in PH2 -- Pj\n  function DECODE (\n    expr VARCHAR2 CHARACTER\n    SET\n\
  \      ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n      expr % CHARSET,\n \
  \     res NUMBER\n  ) return NUMBER;\npragma BUILTIN('DECODE', 22, 240, 240);\n\
  -- This is special cased in PH2 -- Pj\n  function DECODE (\n    expr VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n      expr % CHARSET,\n\
  \      res VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\n\
  SET\n  res % CHARSET;\npragma BUILTIN('DECODE', 22, 240, 240);\n-- This is special\
  \ cased in PH2 -- Pj\n  function DECODE (\n    expr VARCHAR2 CHARACTER\n    SET\n\
  \      ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n      expr % CHARSET,\n \
  \     res DATE\n  ) return DATE;\npragma BUILTIN('DECODE', 22, 240, 240);\n-- This\
  \ is special cased in PH2 -- Pj\n  function DECODE (expr DATE, pat DATE, res NUMBER)\
  \ return NUMBER;\npragma BUILTIN('DECODE', 22, 240, 240);\n-- This is special cased\
  \ in PH2 -- Pj\n  function DECODE (\n    expr DATE,\n    pat DATE,\n    res VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\nSET\n  res %\
  \ CHARSET;\npragma BUILTIN('DECODE', 22, 240, 240);\n-- This is special cased in\
  \ PH2 -- Pj\n  function DECODE (expr DATE, pat DATE, res DATE) return DATE;\npragma\
  \ BUILTIN('DECODE', 22, 240, 240);\n-- This is special cased in PH2 -- Pj\n  function\
  \ SQLCODE return PLS_INTEGER;\npragma BUILTIN('SQLCODE', 45, 10, 0);\n-- PEMS_DB,\
  \ DB_SQLCODE\n  function SQLERRM return varchar2;\npragma FIPSFLAG('SQLERRM', 1452);\n\
  function SQLERRM (code PLS_INTEGER) return varchar2;\npragma BUILTIN('SQLERRM',\
  \ 46, 10, 1);\n-- PEMS_DB, DB_SQLERRM\n  pragma FIPSFLAG('SQLERRM', 1452);\nfunction\
  \ LEVEL return NUMBER;\nfunction ROWNUM return NUMBER;\nfunction '=' (LEFT BOOLEAN,\
  \ RIGHT BOOLEAN) return BOOLEAN;\npragma BUILTIN('=', 2, 3, 1);\n-- PEMS_INTEGER,\
  \ PEMDCMEQ\n  pragma FIPSFLAG('=', 1450);\nfunction '!=' (LEFT BOOLEAN, RIGHT BOOLEAN)\
  \ return BOOLEAN;\n-- also <> and ~=\n  pragma BUILTIN('!=', 5, 3, 2);\n-- PEMS_INTEGER,\
  \ PEMDCMNE\n  pragma FIPSFLAG('!=', 1450);\nfunction '<' (LEFT BOOLEAN, RIGHT BOOLEAN)\
  \ return BOOLEAN;\npragma BUILTIN('<', 4, 3, 3);\n-- PEMS_INTEGER, PEMDCMLT\n  pragma\
  \ FIPSFLAG('<', 1450);\nfunction '<=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;\n\
  pragma BUILTIN('<=', 6, 3, 4);\n-- PEMS_INTEGER, PEMDCMLE\n  pragma FIPSFLAG('<=',\
  \ 1450);\nfunction '>' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;\npragma BUILTIN('>',\
  \ 1, 3, 5);\n-- PEMS_INTEGER, PEMDCMGT\n  pragma FIPSFLAG('>', 1450);\nfunction\
  \ '>=' (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;\npragma BUILTIN('>=', 3, 3,\
  \ 6);\n-- PEMS_INTEGER, PEMDMGE\n  pragma FIPSFLAG('>=', 1450);\n--  Since SQL permits\
  \ short-circuit evaluation, the 'and' and 'or'\n  --  operations will always be\
  \ interpreted as 'and then' and 'or else'\n  --  when they occur in conditional\
  \ statements.\n  function\n  XOR (LEFT BOOLEAN, RIGHT BOOLEAN) return BOOLEAN;\n\
  pragma BUILTIN('XOR', 8, 3, 9);\n-- PEMS_INTEGER, INT_XOR\n  pragma FIPSFLAG('XOR',\
  \ 1450);\nfunction 'NOT' (RIGHT BOOLEAN) return BOOLEAN;\npragma BUILTIN('NOT',\
  \ 9, 3, 10);\n-- PEMS_INTEGER, INT_NOT\n  function 'IS NULL' (B BOOLEAN) return\
  \ BOOLEAN;\npragma BUILTIN('IS NULL', 0, 3, 0);\n-- PEMS_INTEGER, PEMDNUL\n  pragma\
  \ FIPSFLAG('IS NULL', 1450);\nfunction 'IS NOT NULL' (B BOOLEAN) return BOOLEAN;\n\
  pragma BUILTIN('IS NOT NULL', 0, 3, 50);\n-- PEMS_INTEGER, PEMDNUL\n  pragma FIPSFLAG('IS\
  \ NOT NULL', 1450);\nfunction NVL (B1 BOOLEAN, B2 BOOLEAN) return BOOLEAN;\npragma\
  \ FIPSFLAG('NVL', 1450);\nfunction '=' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n\
  \      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return\
  \ BOOLEAN;\npragma BUILTIN('=', 2, 1, 14);\n-- PEMS_CHAR, PEMDCMEQ (VARCHAR2 SEMANTICS)\n\
  \  pragma FIPSFLAG('=', 1454);\nfunction '!=' (\n    LEFT VARCHAR2 CHARACTER\n \
  \   SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n\
  \  ) return BOOLEAN;\npragma BUILTIN('!=', 5, 1, 15);\n-- PEMS_CHAR, PEMDCMNE (VARCHAR2\
  \ SEMANTICS)\n  pragma FIPSFLAG('!=', 1454);\nfunction '<' (\n    LEFT VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n \
  \     ANY_CS\n  ) return BOOLEAN;\npragma BUILTIN('<', 4, 1, 16);\n-- PEMS_CHAR,\
  \ PEMDCMLT (VARCHAR2 SEMANTICS)\n  pragma FIPSFLAG('<', 1454);\nfunction '<=' (\n\
  \    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS\n  ) return BOOLEAN;\npragma BUILTIN('<=', 6, 1, 17);\n--\
  \ PEMS_CHAR, PEMDCMLE (VARCHAR2 SEMANTICS)\n  pragma FIPSFLAG('<=', 1454);\nfunction\
  \ '>' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS\n  ) return BOOLEAN;\npragma BUILTIN('>', 1,\
  \ 1, 18);\n-- PEMS_CHAR, PEMDCMGT (VARCHAR2 SEMANTICS)\n  pragma FIPSFLAG('>', 1454);\n\
  function '>=' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT\
  \ VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return BOOLEAN;\npragma BUILTIN('>=',\
  \ 3, 1, 19);\n-- PEMS_CHAR, PEMDCMGE (VARCHAR2 SEMANTICS)\n  pragma FIPSFLAG('>=',\
  \ 1454);\nfunction '||' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      RIGHT VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\n\
  SET\n  LEFT % CHARSET;\npragma BUILTIN('||', 25, 1, 7);\n-- PEMS_CHAR, CHAR_CONCAT\n\
  \  pragma FIPSFLAG('||', 1454);\nfunction CONCAT(\n    LEFT VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n\
  \  ) return VARCHAR2 CHARACTER\nSET\n  LEFT % CHARSET;\npragma BUILTIN(CONCAT, 25,\
  \ 1, 7);\n-- PEMS_CHAR, CHAR_CONCAT\n  pragma FIPSFLAG(CONCAT, 1454);\nfunction\
  \ LENGTH(\n    ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return natural;\n\
  pragma FIPSFLAG('LENGTH', 1452);\n-- In SUBSTR, LEN defaults to remainder of string\n\
  \  -- In substr and instr, a negative value of parameter POS means to\n  -- count\
  \ from the right end of the string.\n  function SUBSTR(\n    STR1 VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      POS PLS_INTEGER,\n      LEN PLS_INTEGER: = 2147483647\n\
  \  ) return VARCHAR2 CHARACTER\nSET\n  STR1 % CHARSET;\npragma FIPSFLAG('SUBSTR',\
  \ 1452);\n-- Find nth occurrence of str1 in str2 starting at pos\n  function INSTR(\n\
  \    STR1 VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      STR2 VARCHAR2 CHARACTER\n\
  \    SET\n      STR1 % CHARSET,\n      POS PLS_INTEGER: = 1,\n      NTH POSITIVE:\
  \ = 1\n  ) return PLS_INTEGER;\npragma FIPSFLAG('INSTR', 1452);\nfunction UPPER(\n\
  \    ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\n\
  SET\n  ch % CHARSET;\npragma FIPSFLAG('UPPER', 1452);\nfunction LOWER(\n    ch VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\nSET\n  ch % CHARSET;\n\
  pragma FIPSFLAG('LOWER', 1452);\nfunction ASCII(\n    ch VARCHAR2 CHARACTER\n  \
  \  SET\n      ANY_CS\n  ) return INTEGER;\n-- should be ASCII.CHRANGE\n  pragma\
  \ FIPSFLAG('ASCII', 1452);\nfunction ASCIISTR(\n    ch VARCHAR2 CHARACTER\n    SET\n\
  \      ANY_CS\n  ) return VARCHAR2 CHARACTER\nSET\n  ch % CHARSET;\npragma FIPSFLAG('ASCIISTR',\
  \ 1452);\nfunction UNISTR(\n    ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n \
  \ ) return NVARCHAR2;\npragma FIPSFLAG('UNISTR', 1452);\nfunction CHR(n INTEGER)\
  \ return varchar2;\n-- N should be ASCII.CHRANGE\n  pragma FIPSFLAG('CHR', 1452);\n\
  function \" SYS$STANDARD_CHR\"(\n    n INTEGER,\n    csn VARCHAR2 CHARACTER\n  \
  \  SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\nSET\n  csn % CHARSET;\npragma\
  \ FIPSFLAG(' SYS$STANDARD_CHR', 1452);\nfunction INITCAP(\n    ch VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\nSET\n  ch % CHARSET;\npragma\
  \ FIPSFLAG('INITCAP', 1452);\nfunction SOUNDEX(\n    ch VARCHAR2 CHARACTER\n   \
  \ SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\nSET\n  ch % CHARSET;\npragma\
  \ FIPSFLAG('SOUNDEX', 1452);\nfunction LPAD(\n    STR1 VARCHAR2 CHARACTER\n    SET\n\
  \      ANY_CS,\n      LEN pls_integer,\n      PAD VARCHAR2 CHARACTER\n    SET\n\
  \      STR1 % CHARSET\n  ) return VARCHAR2 CHARACTER\nSET\n  STR1 % CHARSET;\npragma\
  \ FIPSFLAG('LPAD', 1452);\nfunction LPAD(\n    STR1 VARCHAR2 CHARACTER\n    SET\n\
  \      ANY_CS,\n      LEN pls_integer\n  ) return VARCHAR2 CHARACTER\nSET\n  STR1\
  \ % CHARSET;\npragma FIPSFLAG('LPAD', 1452);\nfunction RPAD(\n    STR1 VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS,\n      LEN pls_integer,\n      PAD VARCHAR2\
  \ CHARACTER\n    SET\n      STR1 % CHARSET\n  ) return VARCHAR2 CHARACTER\nSET\n\
  \  STR1 % CHARSET;\npragma FIPSFLAG('RPAD', 1452);\nfunction RPAD(\n    STR1 VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS,\n      LEN pls_integer\n  ) return VARCHAR2\
  \ CHARACTER\nSET\n  STR1 % CHARSET;\npragma FIPSFLAG('RPAD', 1452);\nfunction TRANSLATE(\n\
  \    STR1 VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      SRC VARCHAR2 CHARACTER\n\
  \    SET\n      STR1 % CHARSET,\n      DEST VARCHAR2 CHARACTER\n    SET\n      STR1\
  \ % CHARSET\n  ) return VARCHAR2 CHARACTER\nSET\n  STR1 % CHARSET;\npragma FIPSFLAG('TRANSLATE',\
  \ 1452);\nfunction REPLACE(\n    SRCSTR VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      OLDSUB VARCHAR2 CHARACTER\n    SET\n      SRCSTR % CHARSET,\n      NEWSUB\
  \ VARCHAR2 CHARACTER\n    SET\n      SRCSTR % CHARSET: = NULL\n  ) return VARCHAR2\
  \ CHARACTER\nSET\n  SRCSTR % CHARSET;\npragma FIPSFLAG('REPLACE', 1452);\nfunction\
  \ LTRIM(\n    STR1 VARCHAR2 CHARACTER\n    SET\n      ANY_CS: = ' ',\n      TSET\
  \ VARCHAR2 CHARACTER\n    SET\n      STR1 % CHARSET\n  ) return VARCHAR2 CHARACTER\n\
  SET\n  STR1 % CHARSET;\npragma FIPSFLAG('LTRIM', 1452);\nfunction LTRIM(\n    STR1\
  \ VARCHAR2 CHARACTER\n    SET\n      ANY_CS: = ' '\n  ) return VARCHAR2 CHARACTER\n\
  SET\n  STR1 % CHARSET;\npragma FIPSFLAG('LTRIM', 1452);\nfunction RTRIM(\n    STR1\
  \ VARCHAR2 CHARACTER\n    SET\n      ANY_CS: = ' ',\n      TSET VARCHAR2 CHARACTER\n\
  \    SET\n      STR1 % CHARSET\n  ) return VARCHAR2 CHARACTER\nSET\n  STR1 % CHARSET;\n\
  pragma FIPSFLAG('RTRIM', 1452);\nfunction RTRIM(\n    STR1 VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS: = ' '\n  ) return VARCHAR2 CHARACTER\nSET\n  STR1 % CHARSET;\n\
  pragma FIPSFLAG('RTRIM', 1452);\nfunction 'LIKE' (\n    str VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n      str % CHARSET\n\
  \  ) return BOOLEAN;\nfunction 'NOT_LIKE' (\n    str VARCHAR2 CHARACTER\n    SET\n\
  \      ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n      str % CHARSET\n  )\
  \ return BOOLEAN;\nfunction 'LIKE' (\n    str VARCHAR2 CHARACTER\n    SET\n    \
  \  ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n      str % CHARSET,\n      esc\
  \ VARCHAR2 CHARACTER\n    SET\n      str % CHARSET\n  ) return BOOLEAN;\nfunction\
  \ 'NOT_LIKE' (\n    str VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      pat VARCHAR2\
  \ CHARACTER\n    SET\n      str % CHARSET,\n      esc VARCHAR2 CHARACTER\n    SET\n\
  \      str % CHARSET\n  ) return BOOLEAN;\nfunction 'IS NULL' (\n    s VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS\n  ) return BOOLEAN;\npragma BUILTIN('IS NULL',\
  \ 0, 1, 20);\n-- PEMS_CHAR, PEMDNUL\n  function 'IS NOT NULL' (\n    s VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS\n  ) return BOOLEAN;\npragma BUILTIN('IS NOT\
  \ NULL', 0, 1, 50);\n-- PEMS_CHAR, PEMDNUL\n  function NVL(\n    s1 VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      s2 VARCHAR2 CHARACTER\n    SET\n      s1 % CHARSET\n\
  \  ) return VARCHAR2 CHARACTER\nSET\n  s1 % CHARSET;\npragma FIPSFLAG('NVL', 1452);\n\
  function '=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\npragma BUILTIN('=', 2,\
  \ 2, 1);\n-- PEMS_NUMBER, PEMDCMEQ\n  function '!=' (LEFT NUMBER, RIGHT NUMBER)\
  \ return BOOLEAN;\n-- also <> and ~=\n  pragma BUILTIN('!=', 5, 2, 2);\n-- PEMS_NUMBER,\
  \ PEMDCMNE\n  pragma FIPSFLAG('!=', 1452);\nfunction '<' (LEFT NUMBER, RIGHT NUMBER)\
  \ return BOOLEAN;\npragma BUILTIN('<', 4, 2, 3);\n-- PEMS_NUMBER, PEMDCMLT\n  function\
  \ '<=' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\npragma BUILTIN('<=', 6, 2, 4);\n\
  -- PEMS_NUMBER, PEMDCMLE\n  function '>' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\n\
  pragma BUILTIN('>', 1, 2, 5);\n-- PEMS_NUMBER, PEMDCMGT\n  function '>=' (LEFT NUMBER,\
  \ RIGHT NUMBER) return BOOLEAN;\npragma BUILTIN('>=', 3, 2, 6);\n-- PEMS_NUMBER,\
  \ PEMDCMGE\n  function 'IS NULL' (n NUMBER) return BOOLEAN;\npragma BUILTIN('IS\
  \ NULL', 0, 2, 0);\n-- PEMS_NUMBER, PEMDNUL\n  function 'IS NOT NULL' (n NUMBER)\
  \ return BOOLEAN;\npragma BUILTIN('IS NOT NULL', 0, 2, 50);\n-- PEMS_NUMBER, PEMDNUL\n\
  \  function NVL(n1 NUMBER, n2 NUMBER) return NUMBER;\npragma FIPSFLAG('NVL', 1452);\n\
  function '+' (RIGHT NUMBER) return NUMBER;\npragma BUILTIN('+', 14, 0, 1);\n-- PEMS_QUICK\n\
  \  function '-' (RIGHT NUMBER) return NUMBER;\npragma BUILTIN('-', 15, 2, 7);\n\
  -- PEMS_NUMBER, NUM_NEG\n  function ABS(n NUMBER) return NUMBER;\npragma FIPSFLAG('ABS',\
  \ 1452);\nfunction '+' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;\npragma BUILTIN('+',\
  \ 14, 2, 8);\n-- PEMS_NUMBER, NUM_ADD\n  function '-' (LEFT NUMBER, RIGHT NUMBER)\
  \ return NUMBER;\npragma BUILTIN('-', 15, 2, 9);\n-- PEMS_NUMBER, NUM_SUB\n  function\
  \ '*' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;\npragma BUILTIN('*', 17, 2, 10);\n\
  -- PEMS_NUMBER, NUM_MUL\n  function '/' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;\n\
  pragma BUILTIN('/', 18, 2, 11);\n-- PEMS_NUMBER, NUM_DIV\n  function 'REM' (LEFT\
  \ NUMBER, RIGHT NUMBER) return NUMBER;\npragma FIPSFLAG('REM', 1452);\nfunction\
  \ 'MOD'(n1 NUMBER, n2 NUMBER) return NUMBER;\npragma FIPSFLAG('MOD', 1452);\nfunction\
  \ '**' (LEFT NUMBER, RIGHT NUMBER) return NUMBER;\npragma FIPSFLAG('**', 1452);\n\
  function FLOOR(n NUMBER) return NUMBER;\npragma FIPSFLAG('FLOOR', 1452);\nfunction\
  \ CEIL(n NUMBER) return NUMBER;\npragma FIPSFLAG('CEIL', 1452);\nfunction SQRT(n\
  \ NUMBER) return NUMBER;\npragma FIPSFLAG('SQRT', 1452);\nfunction SIGN(n NUMBER)\
  \ return SIGNTYPE;\npragma FIPSFLAG('SIGN', 1452);\nfunction COS(N NUMBER) return\
  \ NUMBER;\npragma FIPSFLAG('COS', 1452);\nfunction SIN(N NUMBER) return NUMBER;\n\
  pragma FIPSFLAG('SIN', 1452);\nfunction TAN(N NUMBER) return NUMBER;\npragma FIPSFLAG('TAN',\
  \ 1452);\nfunction COSH(N NUMBER) return NUMBER;\npragma FIPSFLAG('COSH', 1452);\n\
  function SINH(N NUMBER) return NUMBER;\npragma FIPSFLAG('SINH', 1452);\nfunction\
  \ TANH(N NUMBER) return NUMBER;\npragma FIPSFLAG('TANH', 1452);\nfunction EXP(N\
  \ NUMBER) return NUMBER;\nfunction LN(N NUMBER) return NUMBER;\nfunction BITAND\
  \ (LEFT pls_integer, RIGHT pls_integer) return pls_integer;\nfunction BITAND (LEFT\
  \ integer, RIGHT integer) return integer;\nfunction LOG (LEFT NUMBER, RIGHT NUMBER)\
  \ return NUMBER;\nfunction TRUNC (n NUMBER, places pls_integer: = 0) return NUMBER;\n\
  pragma FIPSFLAG('TRUNC', 1452);\nfunction ROUND (LEFT NUMBER, RIGHT pls_integer:\
  \ = 0) return NUMBER;\npragma FIPSFLAG('ROUND', 1452);\nfunction POWER (n NUMBER,\
  \ e NUMBER) return NUMBER;\npragma FIPSFLAG('POWER', 1452);\nfunction '=' (LEFT\
  \ DATE, RIGHT DATE) return BOOLEAN;\npragma BUILTIN('=', 2, 12, 1);\n-- PEMS_DATE,\
  \ PEMDCMEQ\n  pragma FIPSFLAG('=', 1450);\nfunction '!=' (LEFT DATE, RIGHT DATE)\
  \ return BOOLEAN;\n-- also <> and ~=\n  pragma BUILTIN('!=', 5, 12, 2);\n-- PEMS_DATE,\
  \ PEMDCMNE\n  pragma FIPSFLAG('!=', 1450);\nfunction '<' (LEFT DATE, RIGHT DATE)\
  \ return BOOLEAN;\npragma BUILTIN('<', 4, 12, 3);\n-- PEMS_DATE, PEMDCMLT\n  pragma\
  \ FIPSFLAG('<', 1450);\nfunction '<=' (LEFT DATE, RIGHT DATE) return BOOLEAN;\n\
  pragma BUILTIN('<=', 6, 12, 4);\n-- PEMS_DATE, PEMDCMLE\n  pragma FIPSFLAG('<=',\
  \ 1450);\nfunction '>' (LEFT DATE, RIGHT DATE) return BOOLEAN;\npragma BUILTIN('>',\
  \ 1, 12, 5);\n-- PEMS_DATE, PEMDCMGT\n  pragma FIPSFLAG('>', 1450);\nfunction '>='\
  \ (LEFT DATE, RIGHT DATE) return BOOLEAN;\npragma BUILTIN('>=', 3, 12, 6);\n-- PEMS_DATE,\
  \ PEMDCMGE\n  pragma FIPSFLAG('>=', 1450);\nfunction '+' (LEFT DATE, RIGHT NUMBER)\
  \ return DATE;\npragma BUILTIN('+', 14, 12, 7);\n-- PEMS_DATE, DATE_ADD1\n  pragma\
  \ FIPSFLAG('+', 1450);\nfunction '+' (LEFT NUMBER, RIGHT DATE) return DATE;\npragma\
  \ BUILTIN('+', 14, 12, 8);\n-- PEMS_DATE, DATE_ADD2\n  pragma FIPSFLAG('+', 1450);\n\
  function '-' (LEFT DATE, RIGHT NUMBER) return DATE;\npragma BUILTIN('-', 15, 12,\
  \ 9);\n-- PEMS_DATE, DATE_SUB1\n  pragma FIPSFLAG('-', 1450);\nfunction '-' (LEFT\
  \ NUMBER, RIGHT DATE) return DATE;\npragma BUILTIN('-', 15, 12, 10);\n-- PEMS_DATE,\
  \ DATE_SUB2\n  pragma FIPSFLAG('-', 1450);\nfunction '-' (LEFT DATE, RIGHT DATE)\
  \ return NUMBER;\npragma BUILTIN('-', 15, 12, 11);\n-- PEMS_DATE, DATE_SUB3\n  pragma\
  \ FIPSFLAG('-', 1450);\nfunction LAST_DAY(RIGHT DATE) return DATE;\npragma BUILTIN('LAST_DAY',\
  \ 38, 12, 12);\n-- PEMS_DATE, DATE_LAST_DAY\n  pragma FIPSFLAG('LAST_DAY', 1450);\n\
  function ADD_MONTHS(LEFT DATE, RIGHT NUMBER) return DATE;\npragma BUILTIN('ADD_MONTHS',\
  \ 39, 12, 13);\n-- PEMS_DATE, DATE_ADD_MONTHS1\n  pragma FIPSFLAG('ADD_MONTHS',\
  \ 1450);\nfunction ADD_MONTHS(LEFT NUMBER, RIGHT DATE) return DATE;\npragma BUILTIN('ADD_MONTHS',\
  \ 39, 12, 14);\n-- PEMS_DATE, DATE_ADD_MONTHS2\n  pragma FIPSFLAG('ADD_MONTHS',\
  \ 1450);\nfunction MONTHS_BETWEEN(LEFT DATE, RIGHT DATE) return NUMBER;\npragma\
  \ BUILTIN('MONTHS_BETWEEN', 42, 12, 15);\n-- PEMS_DATE, DATE_MONTHS_BET\n  pragma\
  \ FIPSFLAG('MONTHS_BETWEEN', 1450);\nfunction NEXT_DAY(LEFT DATE, RIGHT VARCHAR2)\
  \ return DATE;\npragma BUILTIN('NEXT_DAY', 43, 12, 16);\n-- PEMS_DATE, DATE_NEXT_DAY\n\
  \  pragma FIPSFLAG('NEXT_DAY', 1450);\nfunction ROUND(RIGHT DATE) return DATE;\n\
  pragma BUILTIN('ROUND', 24, 12, 17);\n-- PEMS_DATE, DATE_ROUND\n  pragma FIPSFLAG('ROUND',\
  \ 1450);\nfunction NEW_TIME(RIGHT DATE, MIDDLE VARCHAR2, LEFT VARCHAR2) return DATE;\n\
  pragma FIPSFLAG('NEW_TIME', 1450);\nfunction 'IS NULL' (d DATE) return BOOLEAN;\n\
  pragma BUILTIN('IS NULL', 0, 12, 0);\n-- PEMS_DATE, PEMDNUL\n  pragma FIPSFLAG('IS\
  \ NULL', 1450);\nfunction 'IS NOT NULL' (d DATE) return BOOLEAN;\npragma BUILTIN('IS\
  \ NOT NULL', 0, 12, 50);\n-- PEMS_DATE, PEMDNUL\n  pragma FIPSFLAG('IS NOT NULL',\
  \ 1450);\nfunction NVL (d1 DATE, d2 DATE) return DATE;\npragma FIPSFLAG('NVL', 1450);\n\
  function TRUNC(LEFT DATE) return DATE;\npragma BUILTIN('TRUNC', 51, 12, 20);\n--\
  \ PEMS_DATE, DATE_TRUNC1\n  pragma FIPSFLAG('TRUNC', 1450);\nfunction TRUNC(LEFT\
  \ DATE, RIGHT VARCHAR2) return DATE;\npragma BUILTIN('TRUNC', 51, 12, 21);\n-- PEMS_DATE,\
  \ DATE_TRUNC2\n  pragma FIPSFLAG('TRUNC', 1450);\nfunction ROUND(LEFT DATE, RIGHT\
  \ VARCHAR2) return DATE;\npragma BUILTIN('ROUND', 24, 12, 22);\n-- PEMS_DATE, DATE_ROUND2\n\
  \  pragma FIPSFLAG('ROUND', 1450);\nfunction TO_DATE (\n    RIGHT VARCHAR2 character\n\
  \    set\n      any_cs\n  ) return DATE;\npragma BUILTIN('TO_DATE', 40, 1, 10);\n\
  -- PEMS_CHAR, CHR_CNV_DAT\n  pragma FIPSFLAG('TO_DATE', 1450);\nfunction TO_DATE\
  \ (\n    LEFT VARCHAR2 character\n    set\n      any_cs,\n      RIGHT VARCHAR2 character\n\
  \    set\n      LEFT % charset\n  ) return DATE;\npragma BUILTIN('TO_DATE', 40,\
  \ 1, 8);\n-- PEMS_CHAR, CHR_CNV_DATE\n  pragma FIPSFLAG('TO_DATE', 1450);\nfunction\
  \ TO_DATE (LEFT NUMBER, RIGHT VARCHAR2) return DATE;\npragma FIPSFLAG('TO_DATE',\
  \ 1450);\nfunction TO_DATE(\n    left varchar2 character\n    set\n      any_cs,\n\
  \      format varchar2 character\n    set\n      LEFT % charset,\n      parms varchar2\
  \ character\n    set\n      LEFT % charset\n  ) return date;\nfunction TO_CHAR (RIGHT\
  \ VARCHAR2) return VARCHAR2;\npragma BUILTIN('TO_CHAR', 14, 0, 2);\nfunction TO_CHAR\
  \ (LEFT DATE, RIGHT VARCHAR2) return VARCHAR2;\npragma BUILTIN('TO_CHAR', 41, 12,\
  \ 19);\n-- PEMS_DATE, DAT_CNV_CHR1\n  pragma FIPSFLAG('TO_CHAR', 1450);\nfunction\
  \ TO_CHAR (LEFT NUMBER, RIGHT VARCHAR2) return VARCHAR2;\npragma BUILTIN('TO_CHAR',\
  \ 41, 2, 14);\n-- PEMS_NUMBER, NUM_CNV_CHR\n  function TO_NUMBER (RIGHT NUMBER)\
  \ RETURN NUMBER;\npragma BUILTIN('TO_NUMBER', 14, 0, 1);\n-- PEMS_QUICK\n  function\
  \ TO_NUMBER (\n    RIGHT VARCHAR2 character\n    set\n      any_cs\n  ) return NUMBER;\n\
  pragma BUILTIN('TO_NUMBER', 48, 1, 9);\n-- PEMS_CHAR, CHR_CNV_NUM\n  function TO_NUMBER(\n\
  \    left varchar2 character\n    set\n      any_cs,\n      format varchar2 character\n\
  \    set\n      LEFT % charset\n  ) return number;\nfunction TO_NUMBER(\n    left\
  \ varchar2 character\n    set\n      any_cs,\n      format varchar2 character\n\
  \    set\n      LEFT % charset,\n      parms varchar2 character\n    set\n     \
  \ LEFT % charset\n  ) return number;\n-- Define SQL predicates.  These don't gen\
  \ code, so no body is needed.\n  -- PRIOR is WEIRD - For now, it will be treated\
  \ as a function call.\n  -- Does the function only take a column name?  how about\
  \ its use in\n  -- a predicate?\n  function 'PRIOR'(\n    colname VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\nSET\n  colname % CHARSET;\n\
  pragma FIPSFLAG('PRIOR', 1452);\nfunction 'PRIOR'(colname NUMBER) return NUMBER;\n\
  pragma FIPSFLAG('PRIOR', 1452);\nfunction 'PRIOR'(colname DATE) return DATE;\npragma\
  \ FIPSFLAG('PRIOR', 1450);\n-- Outer Join has same problem as PRIOR\n  function\
  \ '(+)'(\n    colname VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return VARCHAR2\
  \ CHARACTER\nSET\n  colname % CHARSET;\nfunction '(+)'(colname NUMBER) return NUMBER;\n\
  function '(+)'(colname DATE) return DATE;\npragma FIPSFLAG('(+)', 1450);\nfunction\
  \ '=ANY' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2\
  \ CHARACTER\n    SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\nfunction '=ANY'\
  \ (LEFT DATE, RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('=ANY', 1450);\nfunction\
  \ '=ANY' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\nfunction '!=ANY' (\n    LEFT\
  \ VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n \
  \   SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\nfunction '!=ANY' (LEFT DATE,\
  \ RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('!=ANY', 1450);\nfunction '!=ANY'\
  \ (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\nfunction '<ANY' (\n    LEFT VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n \
  \     LEFT % CHARSET\n  ) return BOOLEAN;\nfunction '<ANY' (LEFT DATE, RIGHT DATE)\
  \ return BOOLEAN;\npragma FIPSFLAG('<ANY', 1450);\nfunction '<ANY' (LEFT NUMBER,\
  \ RIGHT NUMBER) return BOOLEAN;\nfunction '<=ANY' (\n    LEFT VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n      LEFT % CHARSET\n\
  \  ) return BOOLEAN;\nfunction '<=ANY' (LEFT DATE, RIGHT DATE) return BOOLEAN;\n\
  pragma FIPSFLAG('<=ANY', 1450);\nfunction '<=ANY' (LEFT NUMBER, RIGHT NUMBER) return\
  \ BOOLEAN;\nfunction '>ANY' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      RIGHT VARCHAR2 CHARACTER\n    SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\n\
  function '>ANY' (LEFT DATE, RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('>ANY',\
  \ 1450);\nfunction '>ANY' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\nfunction\
  \ '>=ANY' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2\
  \ CHARACTER\n    SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\nfunction '>=ANY'\
  \ (LEFT DATE, RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('>=ANY', 1450);\nfunction\
  \ '>=ANY' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\nfunction '=ALL' (\n    LEFT\
  \ VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n \
  \   SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\nfunction '=ALL' (LEFT DATE,\
  \ RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('=ALL', 1450);\nfunction '=ALL' (LEFT\
  \ NUMBER, RIGHT NUMBER) return BOOLEAN;\nfunction '!=ALL' (\n    LEFT VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n      LEFT % CHARSET\n\
  \  ) return BOOLEAN;\nfunction '!=ALL' (LEFT DATE, RIGHT DATE) return BOOLEAN;\n\
  pragma FIPSFLAG('!=ALL', 1450);\nfunction '!=ALL' (LEFT NUMBER, RIGHT NUMBER) return\
  \ BOOLEAN;\nfunction '<ALL' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      RIGHT VARCHAR2 CHARACTER\n    SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\n\
  function '<ALL' (LEFT DATE, RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('<ALL',\
  \ 1450);\nfunction '<ALL' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\nfunction\
  \ '<=ALL' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2\
  \ CHARACTER\n    SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\nfunction '<=ALL'\
  \ (LEFT DATE, RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('<=ALL', 1450);\nfunction\
  \ '<=ALL' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\nfunction '>ALL' (\n    LEFT\
  \ VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n \
  \   SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\nfunction '>ALL' (LEFT DATE,\
  \ RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('>ALL', 1450);\nfunction '>ALL' (LEFT\
  \ NUMBER, RIGHT NUMBER) return BOOLEAN;\nfunction '>=ALL' (\n    LEFT VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n      LEFT % CHARSET\n\
  \  ) return BOOLEAN;\nfunction '>=ALL' (LEFT DATE, RIGHT DATE) return BOOLEAN;\n\
  pragma FIPSFLAG('>=ALL', 1450);\nfunction '>=ALL' (LEFT NUMBER, RIGHT NUMBER) return\
  \ BOOLEAN;\nfunction '=SOME' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      RIGHT VARCHAR2 CHARACTER\n    SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\n\
  function '=SOME' (LEFT DATE, RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('=SOME',\
  \ 1450);\nfunction '=SOME' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\nfunction\
  \ '!=SOME' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2\
  \ CHARACTER\n    SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\nfunction '!=SOME'\
  \ (LEFT DATE, RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('!=SOME', 1450);\nfunction\
  \ '!=SOME' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\nfunction '<SOME' (\n   \
  \ LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n\
  \    SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\nfunction '<SOME' (LEFT DATE,\
  \ RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('<SOME', 1450);\nfunction '<SOME'\
  \ (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\nfunction '<=SOME' (\n    LEFT VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n \
  \     LEFT % CHARSET\n  ) return BOOLEAN;\nfunction '<=SOME' (LEFT DATE, RIGHT DATE)\
  \ return BOOLEAN;\npragma FIPSFLAG('<=SOME', 1450);\nfunction '<=SOME' (LEFT NUMBER,\
  \ RIGHT NUMBER) return BOOLEAN;\nfunction '>SOME' (\n    LEFT VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n      LEFT % CHARSET\n\
  \  ) return BOOLEAN;\nfunction '>SOME' (LEFT DATE, RIGHT DATE) return BOOLEAN;\n\
  pragma FIPSFLAG('>SOME', 1450);\nfunction '>SOME' (LEFT NUMBER, RIGHT NUMBER) return\
  \ BOOLEAN;\nfunction '>=SOME' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      RIGHT VARCHAR2 CHARACTER\n    SET\n      LEFT % CHARSET\n  ) return BOOLEAN;\n\
  function '>=SOME' (LEFT DATE, RIGHT DATE) return BOOLEAN;\npragma FIPSFLAG('>=SOME',\
  \ 1450);\nfunction '>=SOME' (LEFT NUMBER, RIGHT NUMBER) return BOOLEAN;\n-- SQL\
  \ Transaction routines\n  procedure SET_TRANSACTION_USE(vc VARCHAR2);\nprocedure\
  \ COMMIT;\nprocedure COMMIT_CM(vc VARCHAR2);\nprocedure ROLLBACK_NR;\nprocedure\
  \ ROLLBACK_SV(Save_Point CHAR);\nprocedure SAVEPOINT(Save_Point CHAR);\nfunction\
  \ SYSDATE return DATE;\npragma FIPSFLAG('SYSDATE', 1452);\nfunction UID return PLS_INTEGER;\n\
  pragma FIPSFLAG('UID', 1452);\nfunction USER return VARCHAR2;\nfunction USERENV\
  \ (envstr VARCHAR2) return VARCHAR2;\npragma FIPSFLAG('USERENV', 1452);\n-- ROWID:\
  \ this dreadful identifier is supposed to represent a datatype\n  -- outside of\
  \ SQL and and a pseudo-column (function, to us) when inside\n  -- a sql statement.\
  \  ADA data model doesn't allow for any\n  -- function X return X;\n  -- so we must\
  \ special case this.  Yuk.  There's special-case code in ph2nre\n  -- which maps\
  \ \"rowid\" to \"rowid \" if we're inside a SQL stmt.\n  function \"ROWID \" return\
  \ ROWID;\npragma builtin('ROWID ', 1, 209, 240);\n-- this had better never be called.\n\
  \  function NULLFN (str VARCHAR2) return RAW;\npragma builtin('NULLFN', 1, 0, 1);\n\
  function HEXTORAW (c VARCHAR2) return RAW;\npragma builtin('HEXTORAW', 1, 23, 1);\n\
  function RAWTOHEX (r RAW) return VARCHAR2;\npragma builtin('RAWTOHEX', 1, 23, 2);\n\
  function CHARTOROWID (str VARCHAR2) return ROWID;\npragma builtin('CHARTOROWID',\
  \ 1, 0, 1);\nfunction ROWIDTOCHAR (str ROWID) return VARCHAR2;\npragma builtin('ROWIDTOCHAR',\
  \ 1, 0, 1);\n-- Trusted*Oracle additions\n  Function ROWLABEL return MLSLABEL;\n\
  -- pseudo column\n  Function TO_CHAR(label MLSLABEL, format VARCHAR2) return VARCHAR2;\n\
  pragma BUILTIN('TO_CHAR', 90, 4, 19);\n-- PEMS_DATE, MLS_CNV_CHR1\n  pragma FIPSFLAG('TO_CHAR',\
  \ 1450);\nFunction TO_LABEL(label VARCHAR2, format VARCHAR2) return MLSLABEL;\n\
  pragma BUILTIN('TO_LABEL', 90, 4, 8);\n-- PEMS_CHAR, CHR_CNV_MLS\n  pragma FIPSFLAG('TO_LABEL',\
  \ 1450);\nFunction TO_LABEL(label VARCHAR2) return MLSLABEL;\npragma BUILTIN('TO_LABEL',\
  \ 90, 4, 2);\n-- PEMS_CHAR, CHR_CNV_MLS\n  pragma FIPSFLAG('TO_LABEL', 1450);\n\
  -- vararg routines - icds in stdbdy\n  Function LEAST_UB (pattern MLSLABEL) return\
  \ MLSLABEL;\npragma BUILTIN('LEAST_UB', 90, 4, 3);\n-- PEMS_CHAR, CHR_CNV_MLS\n\
  \  Function GREATEST_LB (pattern MLSLABEL) return MLSLABEL;\npragma BUILTIN('GREATEST_LB',\
  \ 90, 4, 4);\n-- PEMS_CHAR, CHR_CNV_MLS\n  Function '>=' (label1 MLSLABEL, label2\
  \ MLSLABEL) return BOOLEAN;\nFunction '>' (label1 MLSLABEL, label2 MLSLABEL) return\
  \ BOOLEAN;\nFunction '<=' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;\nFunction\
  \ '<' (label1 MLSLABEL, label2 MLSLABEL) return BOOLEAN;\nFunction '=' (label1 MLSLABEL,\
  \ label2 MLSLABEL) return BOOLEAN;\nFunction '!=' (label1 MLSLABEL, label2 MLSLABEL)\
  \ return BOOLEAN;\nfunction 'IS NULL' (label MLSLABEL) return BOOLEAN;\npragma BUILTIN('IS\
  \ NULL', 0, 1, 20);\n-- same \"cod\" as IS NULL(varchar2)\n  function 'IS NOT NULL'\
  \ (label MLSLABEL) return BOOLEAN;\npragma BUILTIN('IS NOT NULL', 0, 1, 50);\nfunction\
  \ NVL(label1 MLSLABEL, label2 MLSLABEL) return MLSLABEL;\npragma FIPSFLAG('NVL',\
  \ 1452);\n-- group functions\n  Function LUB (label MLSLABEL) return MLSLABEL;\n\
  Function GLB (label MLSLABEL) return MLSLABEL;\n-- end of Trusted*Oracle additions\n\
  \  -- beginning of NLS routines\n  function NLSSORT(\n    c VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS\n  ) return RAW;\npragma FIPSFLAG('NLSSORT', 1452);\nfunction\
  \ NLSSORT(\n    c VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      c2 VARCHAR2\n\
  \  ) return RAW;\npragma FIPSFLAG('NLSSORT', 1452);\nfunction NLS_UPPER(\n    ch\
  \ VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      parms VARCHAR2 CHARACTER\n \
  \   SET\n      ch % CHARSET\n  ) return VARCHAR2 CHARACTER\nSET\n  ch % CHARSET;\n\
  pragma FIPSFLAG('NLS_UPPER', 1452);\nfunction NLS_UPPER(\n    ch VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\nSET\n  ch % CHARSET;\npragma\
  \ FIPSFLAG('NLS_UPPER', 1452);\nfunction NLS_LOWER(\n    ch VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      parms VARCHAR2 CHARACTER\n    SET\n      ch % CHARSET\n\
  \  ) return VARCHAR2 CHARACTER\nSET\n  ch % CHARSET;\npragma FIPSFLAG('NLS_LOWER',\
  \ 1452);\nfunction NLS_LOWER(\n    ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n\
  \  ) return VARCHAR2 CHARACTER\nSET\n  ch % CHARSET;\npragma FIPSFLAG('NLS_LOWER',\
  \ 1452);\nfunction NLS_INITCAP(\n    ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      parms VARCHAR2 CHARACTER\n    SET\n      ch % CHARSET\n  ) return VARCHAR2\
  \ CHARACTER\nSET\n  ch % CHARSET;\npragma FIPSFLAG('NLS_INITCAP', 1452);\nfunction\
  \ NLS_INITCAP(\n    ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return VARCHAR2\
  \ CHARACTER\nSET\n  ch % CHARSET;\npragma FIPSFLAG('NLS_INITCAP', 1452);\nfunction\
  \ LENGTHB(\n    ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return NUMBER;\n\
  pragma FIPSFLAG('LENGTHB', 1452);\nfunction SUBSTRB(\n    STR1 VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      POS PLS_INTEGER,\n      LEN PLS_INTEGER: = 2147483647\n\
  \  ) return VARCHAR2 CHARACTER\nSET\n  STR1 % CHARSET;\npragma FIPSFLAG('SUBSTRB',\
  \ 1452);\nfunction INSTRB(\n    STR1 VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      STR2 VARCHAR2 CHARACTER\n    SET\n      STR1 % CHARSET,\n      POS PLS_INTEGER:\
  \ = 1,\n      NTH POSITIVE: = 1\n  ) return PLS_INTEGER;\npragma FIPSFLAG('INSTRB',\
  \ 1452);\nfunction TO_SINGLE_BYTE(\n    c VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n\
  \  ) return VARCHAR2 CHARACTER\nSET\n  c % CHARSET;\npragma FIPSFLAG('TO_SINGLE_BYTE',\
  \ 1452);\nfunction TO_MULTI_BYTE(\n    c VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n\
  \  ) return VARCHAR2 CHARACTER\nSET\n  c % CHARSET;\npragma FIPSFLAG('TO_MULTI_BYTE',\
  \ 1452);\n-- Next two added for NLS 6/3/92 JEM.\n  function TO_CHAR(left date, format\
  \ varchar2, parms varchar2) return varchar2;\nfunction TO_CHAR(left number, format\
  \ varchar2, parms varchar2) return varchar2;\nfunction NLS_CHARSET_NAME(csetid PLS_INTEGER)\
  \ return VARCHAR2;\nfunction NLS_CHARSET_ID(csetname VARCHAR2) return PLS_INTEGER;\n\
  function NLS_CHARSET_DECL_LEN(bytecnt NUMBER, csetid NUMBER) return PLS_INTEGER;\n\
  -- end of NLS routines\n  function CONVERT(\n    src VARCHAR2 character\n    set\n\
  \      any_cs,\n      destcset VARCHAR2\n  ) return VARCHAR2 character\nset\n  src\
  \ % charset;\nfunction CONVERT(\n    src VARCHAR2 character\n    set\n      any_cs,\n\
  \      destcset VARCHAR2,\n      srccset VARCHAR2\n  ) return VARCHAR2 character\n\
  set\n  src % charset;\nfunction \" SYS$STANDARD_TRANSLATE\" (\n    src VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS,\n      csn VARCHAR2 CHARACTER\n    SET\n   \
  \   ANY_CS\n  ) return VARCHAR2 CHARACTER\nSET\n  csn % CHARSET;\npragma FIPSFLAG('\
  \ SYS$STANDARD_TRANSLATE', 1452);\nfunction VSIZE (e number) return NUMBER;\npragma\
  \ builtin('VSIZE', 1, 0, 1);\nfunction VSIZE (e DATE) return NUMBER;\npragma builtin('VSIZE',\
  \ 1, 0, 1);\nfunction VSIZE (\n    e VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n\
  \  ) return NUMBER;\npragma builtin('VSIZE', 1, 0, 1);\n-- dump( expr [,display_format[,start_pos[,length]]])\
  \ return VARCHAR2\n  function DUMP(\n    e varchar2 character\n    set\n      any_cs,\n\
  \      df pls_integer: = null,\n      sp pls_integer: = null,\n      len pls_integer:\
  \ = null\n  ) return VARCHAR2;\npragma builtin('DUMP', 1, 0, 1);\nfunction DUMP(\n\
  \    e number,\n    df pls_integer: = null,\n    sp pls_integer: = null,\n    len\
  \ pls_integer: = null\n  ) return VARCHAR2;\npragma builtin('DUMP', 1, 0, 1);\n\
  function DUMP(\n    e date,\n    df pls_integer: = null,\n    sp pls_integer: =\
  \ null,\n    len pls_integer: = null\n  ) return VARCHAR2;\npragma builtin('DUMP',\
  \ 1, 0, 1);\n--\n  -- ACOS, ASIN, ATAN, ATAN2\n  --   Inverse Trigonometric functions\n\
  \  --   These functions return NULL if any of the inputs are NULL\n  --\n  function\
  \ ACOS(N NUMBER) return NUMBER;\npragma FIPSFLAG('ACOS', 1452);\nfunction ASIN(N\
  \ NUMBER) return NUMBER;\npragma FIPSFLAG('ASIN', 1452);\nfunction ATAN(N NUMBER)\
  \ return NUMBER;\npragma FIPSFLAG('ATAN', 1452);\nfunction ATAN2(x NUMBER, y NUMBER)\
  \ return NUMBER;\npragma FIPSFLAG('ATAN2', 1452);\n--#### This is the end of 7.3\
  \ Standard\n  -- LOB IS NULL\n  function 'IS NULL' (\n    n CLOB CHARACTER\n   \
  \ SET\n      ANY_CS\n  ) return BOOLEAN;\npragma BUILTIN('IS NULL', 0, 2, 0);\n\
  -- PEMS_NUMBER, PEMDNUL\n  function 'IS NOT NULL' (\n    n CLOB CHARACTER\n    SET\n\
  \      ANY_CS\n  ) return BOOLEAN;\npragma BUILTIN('IS NOT NULL', 0, 2, 50);\nfunction\
  \ 'IS NULL' (n BLOB) return BOOLEAN;\npragma BUILTIN('IS NULL', 0, 2, 0);\n-- PEMS_NUMBER,\
  \ PEMDNUL\n  function 'IS NOT NULL' (n BLOB) return BOOLEAN;\npragma BUILTIN('IS\
  \ NOT NULL', 0, 2, 50);\nfunction 'IS NULL' (n BFILE) return BOOLEAN;\npragma BUILTIN('IS\
  \ NULL', 0, 2, 0);\n-- PEMS_NUMBER, PEMDNUL\n  function 'IS NOT NULL' (n BFILE)\
  \ return BOOLEAN;\npragma BUILTIN('IS NOT NULL', 0, 2, 50);\n-- end LOB IS NULL\n\
  \  --****************************************************************\n  -- 20 mar\
  \ 96 =G=> In the following, arguments \"1, 1, 1\" to pragma BUILTIN\n  -- e.g.,\
  \                pragma builtin('whatever', 1, 1, 1)\n  -- indicate that those three\
  \ numeric arguments to pragma BUILTIN are unknown,\n  -- because they are not yet\
  \ implemented by the backend.\n  function '=' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\"\
  ) return BOOLEAN;\npragma BUILTIN('=', 1, 1, 1);\npragma FIPSFLAG('=', 1450);\n\
  function '!=' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\npragma BUILTIN('!=',\
  \ 1, 1, 1);\npragma FIPSFLAG('!=', 1450);\nfunction '<' (LEFT \"<ADT_1>\", RIGHT\
  \ \"<ADT_1>\") return BOOLEAN;\npragma BUILTIN('<', 1, 1, 1);\npragma FIPSFLAG('<',\
  \ 1450);\nfunction '<=' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\n\
  pragma BUILTIN('<=', 1, 1, 1);\npragma FIPSFLAG('<=', 1450);\nfunction '>' (LEFT\
  \ \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\npragma BUILTIN('>', 1, 1, 1);\n\
  pragma FIPSFLAG('>', 1450);\nfunction '>=' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\"\
  ) return BOOLEAN;\npragma BUILTIN('>=', 1, 1, 1);\npragma FIPSFLAG('>=', 1450);\n\
  function '=ANY' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\nfunction\
  \ '!=ANY' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\nfunction '<ANY'\
  \ (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\nfunction '<=ANY' (LEFT\
  \ \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\nfunction '>ANY' (LEFT \"<ADT_1>\"\
  , RIGHT \"<ADT_1>\") return BOOLEAN;\nfunction '>=ANY' (LEFT \"<ADT_1>\", RIGHT\
  \ \"<ADT_1>\") return BOOLEAN;\nfunction '=ALL' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\"\
  ) return BOOLEAN;\nfunction '!=ALL' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return\
  \ BOOLEAN;\nfunction '<ALL' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\n\
  function '<=ALL' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\nfunction\
  \ '>ALL' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\nfunction '>=ALL'\
  \ (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\nfunction '=SOME' (LEFT\
  \ \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\nfunction '!=SOME' (LEFT \"<ADT_1>\"\
  , RIGHT \"<ADT_1>\") return BOOLEAN;\nfunction '<SOME' (LEFT \"<ADT_1>\", RIGHT\
  \ \"<ADT_1>\") return BOOLEAN;\nfunction '<=SOME' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\"\
  ) return BOOLEAN;\nfunction '>SOME' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return\
  \ BOOLEAN;\nfunction '>=SOME' (LEFT \"<ADT_1>\", RIGHT \"<ADT_1>\") return BOOLEAN;\n\
  -- Outer Join\n  function '(+)' (colname \"<ADT_1>\") return \"<ADT_1>\";\npragma\
  \ FIPSFLAG('(+)', 1450);\n--  GREATEST and LEAST are not yet supported for ADTs\
  \ in 8.0.2.\n  --  function GREATEST (pattern \"<ADT_1>\") return \"<ADT_1>\";\n\
  \  --    pragma BUILTIN('GREATEST', 1, 1, 1);\n  --  function LEAST (pattern \"\
  <ADT_1>\") return \"<ADT_1>\";\n  --    pragma BUILTIN('LEAST', 1, 1, 1);\n  function\
  \ DECODE (expr \"<ADT_1>\", pat \"<ADT_1>\", res \"<ADT_1>\") return \"<ADT_1>\"\
  ;\npragma BUILTIN('DECODE', 1, 1, 1);\nfunction 'IS NULL' (B \"<ADT_1>\") return\
  \ BOOLEAN;\npragma BUILTIN('IS NULL', 0, 3, 0);\npragma FIPSFLAG('IS NULL', 1450);\n\
  function 'IS NOT NULL' (B \"<ADT_1>\") return BOOLEAN;\npragma BUILTIN('IS NOT NULL',\
  \ 0, 3, 50);\npragma FIPSFLAG('IS NOT NULL', 1450);\nfunction NVL (B1 \"<ADT_1>\"\
  , B2 \"<ADT_1>\") return \"<ADT_1>\";\npragma FIPSFLAG('NVL', 1450);\nfunction VALUE\
  \ (item \"<ADT_WITH_OID>\") return \"<ADT_1>\";\npragma BUILTIN('VALUE', 1, 1, 1);\n\
  pragma FIPSFLAG('VALUE', 1450);\nfunction REF (item \"<ADT_WITH_OID>\") return REF\
  \ \"<ADT_1>\";\npragma BUILTIN('REF', 1, 1, 1);\npragma FIPSFLAG('REF', 1450);\n\
  function DEREF (r REF \"<ADT_1>\") return \"<ADT_1>\";\npragma BUILTIN('DEREF',\
  \ 1, 1, 1);\npragma FIPSFLAG('DEREF', 1450);\n-- overloadings for REF ADT\n  function\
  \ 'IS NULL' (B REF \"<ADT_1>\") return BOOLEAN;\npragma BUILTIN('IS NULL', 0, 3,\
  \ 0);\npragma FIPSFLAG('IS NULL', 1450);\nfunction 'IS NOT NULL' (B REF \"<ADT_1>\"\
  ) return BOOLEAN;\npragma BUILTIN('IS NOT NULL', 0, 3, 50);\npragma FIPSFLAG('IS\
  \ NOT NULL', 1450);\nfunction 'IS DANGLING' (B REF \"<ADT_1>\") return BOOLEAN;\n\
  pragma BUILTIN('IS DANGLING', 1, 1, 1);\npragma FIPSFLAG('IS DANGLING', 1450);\n\
  function 'IS NOT DANGLING' (B REF \"<ADT_1>\") return BOOLEAN;\npragma BUILTIN('IS\
  \ NOT DANGLING', 1, 1, 1);\npragma FIPSFLAG('IS NOT DANGLING', 1450);\nfunction\
  \ NVL (B1 REF \"<ADT_1>\", B2 REF \"<ADT_1>\") return REF \"<ADT_1>\";\npragma FIPSFLAG('NVL',\
  \ 1450);\nfunction '=' (LEFT REF \"<ADT_1>\", RIGHT REF \"<ADT_1>\") return BOOLEAN;\n\
  pragma BUILTIN('=', 0, 3, 1);\npragma FIPSFLAG('=', 1450);\nfunction '!=' (LEFT\
  \ REF \"<ADT_1>\", RIGHT REF \"<ADT_1>\") return BOOLEAN;\npragma BUILTIN('!=',\
  \ 0, 3, 2);\npragma FIPSFLAG('!=', 1450);\n--  function '='  (LEFT \"<COLLECTION_1>\"\
  , RIGHT \"<COLLECTION_1>\")\n  --      return BOOLEAN;\n  --    pragma BUILTIN('=',\
  \ 1, 1, 1);\n  --    pragma FIPSFLAG('=', 1450);\n  --\n  --  function '!=' (LEFT\
  \ \"<COLLECTION_1>\", RIGHT \"<COLLECTION_1>\")\n  --      return BOOLEAN;\n  --\
  \    pragma BUILTIN('!=', 1, 1, 1);\n  --    pragma FIPSFLAG('!=', 1450);\n  --\n\
  \  --  function '=ANY'  (LEFT \"<COLLECTION_1>\", RIGHT \"<COLLECTION_1>\")\n  --\
  \      return BOOLEAN;\n  --  function '!=ANY'  (LEFT \"<COLLECTION_1>\", RIGHT\
  \ \"<COLLECTION_1>\")\n  --      return BOOLEAN;\n  --  function '=ALL'  (LEFT \"\
  <COLLECTION_1>\", RIGHT \"<COLLECTION_1>\")\n  --      return BOOLEAN;\n  --  function\
  \ '!=ALL'  (LEFT \"<COLLECTION_1>\", RIGHT \"<COLLECTION_1>\")\n  --      return\
  \ BOOLEAN;\n  --  function '=SOME'  (LEFT \"<COLLECTION_1>\", RIGHT \"<COLLECTION_1>\"\
  )\n  --      return BOOLEAN;\n  --  function '!=SOME'  (LEFT \"<COLLECTION_1>\"\
  , RIGHT \"<COLLECTION_1>\")\n  --      return BOOLEAN;\n  --\n  --  function DECODE\
  \ (expr \"<COLLECTION_1>\", pat \"<COLLECTION_1>\",\n  --                      \
  \                  res \"<COLLECTION_1>\")\n  --      return \"<COLLECTION_1>\"\
  ;\n  --    pragma BUILTIN('DECODE', 1, 1, 1);\n  function 'IS NULL' (B \"<COLLECTION_1>\"\
  ) return BOOLEAN;\npragma BUILTIN('IS NULL', 0, 3, 0);\npragma FIPSFLAG('IS NULL',\
  \ 1450);\nfunction 'IS NOT NULL' (B \"<COLLECTION_1>\") return BOOLEAN;\npragma\
  \ BUILTIN('IS NOT NULL', 0, 3, 50);\npragma FIPSFLAG('IS NOT NULL', 1450);\nfunction\
  \ NVL (B1 \"<COLLECTION_1>\", B2 \"<COLLECTION_1>\") return \"<COLLECTION_1>\";\n\
  pragma FIPSFLAG('NVL', 1450);\nfunction 'IS NULL' (B \"<REF_CURSOR_1>\") return\
  \ BOOLEAN;\npragma BUILTIN('IS NULL', 0, 3, 0);\npragma FIPSFLAG('IS NULL', 1450);\n\
  function 'IS NOT NULL' (B \"<REF_CURSOR_1>\") return BOOLEAN;\npragma BUILTIN('IS\
  \ NOT NULL', 0, 3, 50);\npragma FIPSFLAG('IS NOT NULL', 1450);\nfunction NVL (B1\
  \ \"<REF_CURSOR_1>\", B2 \"<REF_CURSOR_1>\") return \"<REF_CURSOR_1>\";\npragma\
  \ FIPSFLAG('NVL', 1450);\nfunction EMPTY_CLOB return clob;\nfunction EMPTY_BLOB\
  \ return blob;\nfunction BFILENAME(directory varchar2, filename varchar2) return\
  \ BFILE;\nfunction \"SYS$LOB_REPLICATION\" (x in blob) return blob;\nfunction \"\
  SYS$LOB_REPLICATION\" (\n    x in clob character\n    set\n      any_cs\n  ) return\
  \ clob character\nset\n  x % charset;\n--#### This is the end of 8.0 Standard\n\
  \  --  + overloadings\n  function '+'(\n    LEFT TIMESTAMP_UNCONSTRAINED,\n    RIGHT\
  \ YMINTERVAL_UNCONSTRAINED\n  ) return TIMESTAMP_UNCONSTRAINED;\nfunction '+'(\n\
  \    LEFT TIMESTAMP_UNCONSTRAINED,\n    RIGHT DSINTERVAL_UNCONSTRAINED\n  ) return\
  \ TIMESTAMP_UNCONSTRAINED;\nfunction '+'(\n    LEFT TIMESTAMP_TZ_UNCONSTRAINED,\n\
  \    RIGHT YMINTERVAL_UNCONSTRAINED\n  ) return TIMESTAMP_TZ_UNCONSTRAINED;\nfunction\
  \ '+'(\n    LEFT TIMESTAMP_TZ_UNCONSTRAINED,\n    RIGHT DSINTERVAL_UNCONSTRAINED\n\
  \  ) return TIMESTAMP_TZ_UNCONSTRAINED;\nfunction '+'(\n    LEFT TIME_UNCONSTRAINED,\n\
  \    RIGHT DSINTERVAL_UNCONSTRAINED\n  ) return TIME_UNCONSTRAINED;\nfunction '+'(\n\
  \    LEFT TIME_TZ_UNCONSTRAINED,\n    RIGHT DSINTERVAL_UNCONSTRAINED\n  ) return\
  \ TIME_TZ_UNCONSTRAINED;\nfunction '+'(LEFT date, RIGHT YMINTERVAL_UNCONSTRAINED)\
  \ return date;\nfunction '+'(LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED) return date;\n\
  function '+'(\n    LEFT YMINTERVAL_UNCONSTRAINED,\n    RIGHT TIMESTAMP_UNCONSTRAINED\n\
  \  ) return TIMESTAMP_UNCONSTRAINED;\nfunction '+'(\n    LEFT YMINTERVAL_UNCONSTRAINED,\n\
  \    RIGHT TIMESTAMP_TZ_UNCONSTRAINED\n  ) return TIMESTAMP_TZ_UNCONSTRAINED;\n\
  function '+'(LEFT YMINTERVAL_UNCONSTRAINED, RIGHT date) return date;\nfunction '+'(\n\
  \    LEFT DSINTERVAL_UNCONSTRAINED,\n    RIGHT TIMESTAMP_UNCONSTRAINED\n  ) return\
  \ TIMESTAMP_UNCONSTRAINED;\nfunction '+'(\n    LEFT DSINTERVAL_UNCONSTRAINED,\n\
  \    RIGHT TIMESTAMP_TZ_UNCONSTRAINED\n  ) return TIMESTAMP_TZ_UNCONSTRAINED;\n\
  function '+'(\n    LEFT DSINTERVAL_UNCONSTRAINED,\n    RIGHT TIME_UNCONSTRAINED\n\
  \  ) return TIME_UNCONSTRAINED;\nfunction '+'(\n    LEFT DSINTERVAL_UNCONSTRAINED,\n\
  \    RIGHT TIME_TZ_UNCONSTRAINED\n  ) return TIME_TZ_UNCONSTRAINED;\nfunction '+'(LEFT\
  \ DSINTERVAL_UNCONSTRAINED, RIGHT date) return date;\nfunction '+'(\n    LEFT DSINTERVAL_UNCONSTRAINED,\n\
  \    RIGHT DSINTERVAL_UNCONSTRAINED\n  ) return DSINTERVAL_UNCONSTRAINED;\nfunction\
  \ '+'(\n    LEFT YMINTERVAL_UNCONSTRAINED,\n    RIGHT YMINTERVAL_UNCONSTRAINED\n\
  \  ) return YMINTERVAL_UNCONSTRAINED;\n-- begin subtract\n  function \" SYS$DSINTERVALSUBTRACT\"\
  (\n    LEFT TIMESTAMP_UNCONSTRAINED,\n    RIGHT TIMESTAMP_UNCONSTRAINED\n  ) return\
  \ DSINTERVAL_UNCONSTRAINED;\nfunction \" SYS$YMINTERVALSUBTRACT\"(\n    LEFT TIMESTAMP_UNCONSTRAINED,\n\
  \    RIGHT TIMESTAMP_UNCONSTRAINED\n  ) return YMINTERVAL_UNCONSTRAINED;\nfunction\
  \ '-'(\n    LEFT TIMESTAMP_UNCONSTRAINED,\n    RIGHT YMINTERVAL_UNCONSTRAINED\n\
  \  ) return TIMESTAMP_UNCONSTRAINED;\nfunction '-'(\n    LEFT TIMESTAMP_UNCONSTRAINED,\n\
  \    RIGHT DSINTERVAL_UNCONSTRAINED\n  ) return TIMESTAMP_UNCONSTRAINED;\nfunction\
  \ \" SYS$DSINTERVALSUBTRACT\" (\n    LEFT TIMESTAMP_TZ_UNCONSTRAINED,\n    RIGHT\
  \ TIMESTAMP_TZ_UNCONSTRAINED\n  ) return DSINTERVAL_UNCONSTRAINED;\nfunction \"\
  \ SYS$YMINTERVALSUBTRACT\" (\n    LEFT TIMESTAMP_TZ_UNCONSTRAINED,\n    RIGHT TIMESTAMP_TZ_UNCONSTRAINED\n\
  \  ) return YMINTERVAL_UNCONSTRAINED;\nfunction '-' (\n    LEFT TIMESTAMP_TZ_UNCONSTRAINED,\n\
  \    RIGHT YMINTERVAL_UNCONSTRAINED\n  ) return TIMESTAMP_TZ_UNCONSTRAINED;\nfunction\
  \ '-' (\n    LEFT TIMESTAMP_TZ_UNCONSTRAINED,\n    RIGHT DSINTERVAL_UNCONSTRAINED\n\
  \  ) return TIMESTAMP_TZ_UNCONSTRAINED;\nfunction \" SYS$DSINTERVALSUBTRACT\" (\n\
  \    LEFT TIME_UNCONSTRAINED,\n    RIGHT TIME_UNCONSTRAINED\n  ) return DSINTERVAL_UNCONSTRAINED;\n\
  function '-' (\n    LEFT TIME_UNCONSTRAINED,\n    RIGHT DSINTERVAL_UNCONSTRAINED\n\
  \  ) return TIME_UNCONSTRAINED;\nfunction \" SYS$DSINTERVALSUBTRACT\" (\n    LEFT\
  \ TIME_TZ_UNCONSTRAINED,\n    RIGHT TIME_TZ_UNCONSTRAINED\n  ) return DSINTERVAL_UNCONSTRAINED;\n\
  function '-' (\n    LEFT TIME_TZ_UNCONSTRAINED,\n    RIGHT DSINTERVAL_UNCONSTRAINED\n\
  \  ) return TIME_TZ_UNCONSTRAINED;\nfunction \" SYS$DSINTERVALSUBTRACT\" (LEFT date,\
  \ RIGHT date) return DSINTERVAL_UNCONSTRAINED;\nfunction \" SYS$YMINTERVALSUBTRACT\"\
  \ (LEFT date, RIGHT date) return YMINTERVAL_UNCONSTRAINED;\nfunction '-' (LEFT date,\
  \ RIGHT YMINTERVAL_UNCONSTRAINED) return date;\nfunction '-' (LEFT date, RIGHT DSINTERVAL_UNCONSTRAINED)\
  \ return date;\nfunction '-' (\n    LEFT YMINTERVAL_UNCONSTRAINED,\n    RIGHT YMINTERVAL_UNCONSTRAINED\n\
  \  ) return YMINTERVAL_UNCONSTRAINED;\nfunction '-' (\n    LEFT DSINTERVAL_UNCONSTRAINED,\n\
  \    RIGHT DSINTERVAL_UNCONSTRAINED\n  ) return DSINTERVAL_UNCONSTRAINED;\n-- end\
  \ subtract\n  -- other datetime operators\n  function '*' (LEFT number, RIGHT YMINTERVAL_UNCONSTRAINED)\
  \ return YMINTERVAL_UNCONSTRAINED;\nfunction '*' (LEFT number, RIGHT DSINTERVAL_UNCONSTRAINED)\
  \ return DSINTERVAL_UNCONSTRAINED;\nfunction '*' (LEFT YMINTERVAL_UNCONSTRAINED,\
  \ RIGHT number) return YMINTERVAL_UNCONSTRAINED;\nfunction '*' (LEFT DSINTERVAL_UNCONSTRAINED,\
  \ RIGHT number) return DSINTERVAL_UNCONSTRAINED;\nfunction '/' (LEFT YMINTERVAL_UNCONSTRAINED,\
  \ RIGHT number) return YMINTERVAL_UNCONSTRAINED;\nfunction '/' (LEFT DSINTERVAL_UNCONSTRAINED,\
  \ RIGHT number) return DSINTERVAL_UNCONSTRAINED;\nfunction current_date return date;\n\
  function current_time return TIME_TZ_UNCONSTRAINED;\nfunction current_timestamp\
  \ return TIMESTAMP_TZ_UNCONSTRAINED;\nfunction TO_TIME (\n    RIGHT varchar2 character\n\
  \    set\n      any_cs\n  ) return time_unconstrained;\npragma BUILTIN('TO_TIME',\
  \ 0, 15, 1);\nfunction TO_TIMESTAMP (\n    RIGHT varchar2 character\n    set\n \
  \     any_cs\n  ) return TIMESTAMP_UNCONSTRAINED;\npragma BUILTIN('TO_TIMESTAMP',\
  \ 0, 15, 3);\nfunction TO_TIME_TZ (\n    RIGHT varchar2 character\n    set\n   \
  \   any_cs\n  ) return TIME_TZ_UNCONSTRAINED;\npragma BUILTIN('TO_TIME_TZ', 0, 15,\
  \ 5);\nfunction TO_TIMESTAMP_TZ (\n    RIGHT varchar2 character\n    set\n     \
  \ any_cs\n  ) return TIMESTAMP_TZ_UNCONSTRAINED;\npragma BUILTIN('TO_TIMESTAMP_TZ',\
  \ 0, 15, 7);\nfunction TO_YMINTERVAL (\n    RIGHT varchar2 character\n    set\n\
  \      any_cs\n  ) return YMINTERVAL_UNCONSTRAINED;\npragma BUILTIN('TO_YMINTERVAL',\
  \ 0, 15, 9);\nfunction TO_DSINTERVAL (\n    RIGHT varchar2 character\n    set\n\
  \      any_cs\n  ) return DSINTERVAL_UNCONSTRAINED;\npragma BUILTIN('TO_DSINTERVAL',\
  \ 0, 15, 11);\n-- with nls args\n  function TO_TIME(\n    left varchar2 character\n\
  \    set\n      any_cs,\n      format varchar2 character\n    set\n      left %\
  \ charset,\n      parms varchar2 character\n    set\n      left % charset\n  ) return\
  \ TIME_UNCONSTRAINED;\nfunction TO_TIME(\n    left varchar2 character\n    set\n\
  \      any_cs,\n      format varchar2 character\n    set\n      left % charset\n\
  \  ) return TIME_UNCONSTRAINED;\nfunction TO_TIMESTAMP(\n    left varchar2 character\n\
  \    set\n      any_cs,\n      format varchar2 character\n    set\n      left %\
  \ charset,\n      parms varchar2 character\n    set\n      left % charset\n  ) return\
  \ TIMESTAMP_UNCONSTRAINED;\nfunction TO_TIMESTAMP(\n    left varchar2 character\n\
  \    set\n      any_cs,\n      format varchar2 character\n    set\n      left %\
  \ charset\n  ) return TIMESTAMP_UNCONSTRAINED;\nfunction TO_TIMESTAMP_TZ(\n    left\
  \ varchar2 character\n    set\n      any_cs,\n      format varchar2 character\n\
  \    set\n      left % charset,\n      parms varchar2 character\n    set\n     \
  \ left % charset\n  ) return TIMESTAMP_TZ_UNCONSTRAINED;\nfunction TO_TIMESTAMP_TZ(\n\
  \    left varchar2 character\n    set\n      any_cs,\n      format varchar2 character\n\
  \    set\n      left % charset\n  ) return TIMESTAMP_TZ_UNCONSTRAINED;\nfunction\
  \ TO_TIME_TZ(\n    left varchar2 character\n    set\n      any_cs,\n      format\
  \ varchar2 character\n    set\n      left % charset,\n      parms varchar2 character\n\
  \    set\n      left % charset\n  ) return TIME_TZ_UNCONSTRAINED;\nfunction TO_TIME_TZ(\n\
  \    left varchar2 character\n    set\n      any_cs,\n      format varchar2 character\n\
  \    set\n      left % charset\n  ) return TIME_TZ_UNCONSTRAINED;\nfunction TO_DSINTERVAL(\n\
  \    RIGHT varchar2 character\n    set\n      any_cs,\n      parms varchar2 character\n\
  \    set\n      RIGHT % charset\n  ) return DSINTERVAL_UNCONSTRAINED;\nfunction\
  \ NUMTOYMINTERVAL(\n    numerator number,\n    units varchar2 character\n    set\n\
  \      any_cs\n  ) return YMINTERVAL_UNCONSTRAINED;\nfunction NUMTODSINTERVAL(\n\
  \    numerator number,\n    units varchar2 character\n    set\n      any_cs\n  )\
  \ return DSINTERVAL_UNCONSTRAINED;\nfunction '=' (LEFT UROWID, RIGHT UROWID) return\
  \ BOOLEAN;\npragma BUILTIN('=', 0, 11, 1);\npragma FIPSFLAG('=', 1450);\nfunction\
  \ '!=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;\n-- also <> and ~=\n  pragma\
  \ BUILTIN('!=', 0, 11, 2);\npragma FIPSFLAG('!=', 1450);\nfunction '<' (LEFT UROWID,\
  \ RIGHT UROWID) return BOOLEAN;\npragma BUILTIN('<', 0, 11, 3);\npragma FIPSFLAG('<',\
  \ 1450);\nfunction '<=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;\npragma BUILTIN('<=',\
  \ 0, 11, 4);\npragma FIPSFLAG('<=', 1450);\nfunction '>' (LEFT UROWID, RIGHT UROWID)\
  \ return BOOLEAN;\npragma BUILTIN('>', 0, 11, 5);\npragma FIPSFLAG('>', 1450);\n\
  function '>=' (LEFT UROWID, RIGHT UROWID) return BOOLEAN;\npragma BUILTIN('>=',\
  \ 0, 11, 6);\npragma FIPSFLAG('>=', 1450);\nfunction 'IS NULL' (u UROWID) return\
  \ BOOLEAN;\npragma BUILTIN('IS NULL', 0, 14, 0);\n-- PEMS_UROWID, PEMDNUL\n  pragma\
  \ FIPSFLAG('IS NULL', 1450);\nfunction 'IS NOT NULL' (u UROWID) return BOOLEAN;\n\
  pragma BUILTIN('IS NOT NULL', 0, 14, 50);\n-- PEMS_UROWID, PEMDNUL\n  pragma FIPSFLAG('IS\
  \ NOT NULL', 1450);\nfunction \"UROWID \" return UROWID;\npragma builtin('UROWID\
  \ ', 1, 209, 240);\n-- this had better never be called.\n  -- New built-in function\
  \ SYS_GUID, returns globally unique id\n  function SYS_GUID return RAW;\n-- New\
  \ built-in function SYS_CONTEXT\n  function SYS_CONTEXT (namespace varchar2, attribute\
  \ varchar2) return varchar2;\nfunction TRIM(\n    v VARCHAR2 CHARACTER\n    SET\n\
  \      ANY_CS\n  ) return VARCHAR2 CHARACTER\nSET\n  v % CHARSET;\n--#### This is\
  \ the end of 8.1.5 Standard\n  -- SYS_CONTEXT now has an additional optional parameter\n\
  \  function SYS_CONTEXT(\n    namespace varchar2,\n    attribute varchar2,\n   \
  \ newoptional varchar2\n  ) return varchar2;\n-- CUBE and ROLLUP are not real functions;\
  \ they are variants on the GROUP\n  -- BY clause (GROUP BY CUBE (...) and GROUP\
  \ BY ROLLUP (...)). They have\n  -- been added here as functions to avoid name capture\
  \ issues.\n  --\n  -- Note that both CUBE and ROLLUP look like true vararg functions\
  \ with\n  -- *no* repeating pattern of formals - hence they are special cased in\n\
  \  -- the overloading code.\n  function CUBE return NUMBER;\nfunction ROLLUP return\
  \ NUMBER;\n-- The GROUPING function must be used in conjunction with CUBE and ROLLUP\n\
  \  -- in the GROUP BY clause. The type of the parameter to GROUPING can be\n  --\
  \ any type that can appear in a GROUP BY list.\n  function GROUPING(v VARCHAR2)\
  \ return NUMBER;\nfunction GROUPING(a \"<ADT_1>\") return NUMBER;\n-- This is for\
  \ TRIM(x). No trim set.\n  function \" SYS$STANDARD_TRIM\" (\n    v VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS\n  ) return VARCHAR2 CHARACTER\nSET\n  v % CHARSET;\n-- This\
  \ is for TRIM(LEADING/TRAILING FROM x). No trim set.\n  function \" SYS$STANDARD_TRIM\"\
  \ (\n    STR1 VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      TRFLAG PLS_INTEGER\n\
  \  ) return VARCHAR2 CHARACTER\nSET\n  STR1 % CHARSET;\n-- General TRIM. LEADING,\
  \ TRAILING and BOTH options as 3rd argument.\n  -- This one takes a trim set.\n\
  \  function \" SYS$STANDARD_TRIM\" (\n    STR1 VARCHAR2 CHARACTER\n    SET\n   \
  \   ANY_CS,\n      TSET VARCHAR2 CHARACTER\n    SET\n      STR1 % CHARSET,\n   \
  \   TRFLAG PLS_INTEGER\n  ) return VARCHAR2 CHARACTER\nSET\n  STR1 % CHARSET;\n\
  --#### This is the end of the supported parts of 8.1.6 Standard\n  --## Support\
  \ for ANSI datetime data types is under development.\n  --## The following operations,\
  \ as well as the related types and\n  --## operations defined above in the 8.1.5\
  \ section, are not yet\n  --## available for use and are still subject to change.\n\
  \  --- datetime equivalence\n  function '=' (\n    LEFT TIME_UNCONSTRAINED,\n  \
  \  RIGHT TIME_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '!=' (\n    LEFT TIME_UNCONSTRAINED,\n\
  \    RIGHT TIME_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '<' (\n    LEFT TIME_UNCONSTRAINED,\n\
  \    RIGHT TIME_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '<=' (\n    LEFT TIME_UNCONSTRAINED,\n\
  \    RIGHT TIME_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '>' (\n    LEFT TIME_UNCONSTRAINED,\n\
  \    RIGHT TIME_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '>=' (\n    LEFT TIME_UNCONSTRAINED,\n\
  \    RIGHT TIME_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '=' (\n    LEFT TIMESTAMP_UNCONSTRAINED,\n\
  \    RIGHT TIMESTAMP_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '!=' (\n    LEFT\
  \ TIMESTAMP_UNCONSTRAINED,\n    RIGHT TIMESTAMP_UNCONSTRAINED\n  ) return BOOLEAN;\n\
  function '<' (\n    LEFT TIMESTAMP_UNCONSTRAINED,\n    RIGHT TIMESTAMP_UNCONSTRAINED\n\
  \  ) return BOOLEAN;\nfunction '<=' (\n    LEFT TIMESTAMP_UNCONSTRAINED,\n    RIGHT\
  \ TIMESTAMP_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '>' (\n    LEFT TIMESTAMP_UNCONSTRAINED,\n\
  \    RIGHT TIMESTAMP_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '>=' (\n    LEFT\
  \ TIMESTAMP_UNCONSTRAINED,\n    RIGHT TIMESTAMP_UNCONSTRAINED\n  ) return BOOLEAN;\n\
  function '=' (\n    LEFT TIME_TZ_UNCONSTRAINED,\n    RIGHT TIME_TZ_UNCONSTRAINED\n\
  \  ) return BOOLEAN;\nfunction '!=' (\n    LEFT TIME_TZ_UNCONSTRAINED,\n    RIGHT\
  \ TIME_TZ_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '<' (\n    LEFT TIME_TZ_UNCONSTRAINED,\n\
  \    RIGHT TIME_TZ_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '<=' (\n    LEFT\
  \ TIME_TZ_UNCONSTRAINED,\n    RIGHT TIME_TZ_UNCONSTRAINED\n  ) return BOOLEAN;\n\
  function '>' (\n    LEFT TIME_TZ_UNCONSTRAINED,\n    RIGHT TIME_TZ_UNCONSTRAINED\n\
  \  ) return BOOLEAN;\nfunction '>=' (\n    LEFT TIME_TZ_UNCONSTRAINED,\n    RIGHT\
  \ TIME_TZ_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '=' (\n    LEFT YMINTERVAL_UNCONSTRAINED,\n\
  \    RIGHT YMINTERVAL_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '!=' (\n    LEFT\
  \ YMINTERVAL_UNCONSTRAINED,\n    RIGHT YMINTERVAL_UNCONSTRAINED\n  ) return BOOLEAN;\n\
  function '<' (\n    LEFT YMINTERVAL_UNCONSTRAINED,\n    RIGHT YMINTERVAL_UNCONSTRAINED\n\
  \  ) return BOOLEAN;\nfunction '<=' (\n    LEFT YMINTERVAL_UNCONSTRAINED,\n    RIGHT\
  \ YMINTERVAL_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '>' (\n    LEFT YMINTERVAL_UNCONSTRAINED,\n\
  \    RIGHT YMINTERVAL_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '>=' (\n    LEFT\
  \ YMINTERVAL_UNCONSTRAINED,\n    RIGHT YMINTERVAL_UNCONSTRAINED\n  ) return BOOLEAN;\n\
  function '=' (\n    LEFT DSINTERVAL_UNCONSTRAINED,\n    RIGHT DSINTERVAL_UNCONSTRAINED\n\
  \  ) return BOOLEAN;\nfunction '!=' (\n    LEFT DSINTERVAL_UNCONSTRAINED,\n    RIGHT\
  \ DSINTERVAL_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '<' (\n    LEFT DSINTERVAL_UNCONSTRAINED,\n\
  \    RIGHT DSINTERVAL_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '<=' (\n    LEFT\
  \ DSINTERVAL_UNCONSTRAINED,\n    RIGHT DSINTERVAL_UNCONSTRAINED\n  ) return BOOLEAN;\n\
  function '>' (\n    LEFT DSINTERVAL_UNCONSTRAINED,\n    RIGHT DSINTERVAL_UNCONSTRAINED\n\
  \  ) return BOOLEAN;\nfunction '>=' (\n    LEFT DSINTERVAL_UNCONSTRAINED,\n    RIGHT\
  \ DSINTERVAL_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction TO_TIME (RIGHT TIME_TZ_UNCONSTRAINED)\
  \ return TIME_UNCONSTRAINED;\npragma BUILTIN('TO_TIME', 0, 15, 13);\nfunction TO_TIME_TZ\
  \ (RIGHT TIME_UNCONSTRAINED) return TIME_TZ_UNCONSTRAINED;\npragma BUILTIN('TO_TIME_TZ',\
  \ 0, 15, 14);\nfunction TO_TIMESTAMP (RIGHT TIMESTAMP_TZ_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;\n\
  pragma BUILTIN('TO_TIMESTAMP', 0, 15, 15);\nfunction TO_TIMESTAMP_TZ (RIGHT TIMESTAMP_UNCONSTRAINED)\
  \ return TIMESTAMP_TZ_UNCONSTRAINED;\npragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 16);\n\
  function '-' (\n    LEFT TIME_UNCONSTRAINED,\n    RIGHT TIME_UNCONSTRAINED\n  )\
  \ return DSINTERVAL_UNCONSTRAINED;\nfunction '-' (\n    LEFT TIMESTAMP_UNCONSTRAINED,\n\
  \    RIGHT TIMESTAMP_UNCONSTRAINED\n  ) return DSINTERVAL_UNCONSTRAINED;\nfunction\
  \ '-' (\n    LEFT TIME_TZ_UNCONSTRAINED,\n    RIGHT TIME_TZ_UNCONSTRAINED\n  ) return\
  \ DSINTERVAL_UNCONSTRAINED;\nfunction '-' (\n    LEFT TIMESTAMP_TZ_UNCONSTRAINED,\n\
  \    RIGHT TIMESTAMP_TZ_UNCONSTRAINED\n  ) return DSINTERVAL_UNCONSTRAINED;\n--\
  \ timezone functions\n  function SYS_AT_TIME_ZONE(\n    t time_tz_unconstrained,\n\
  \    i varchar2\n  ) RETURN time_tz_unconstrained;\nfunction SYS_AT_TIME_ZONE(\n\
  \    t timestamp_tz_unconstrained,\n    i varchar2\n  ) RETURN timestamp_tz_unconstrained;\n\
  FUNCTION systimestamp RETURN timestamp_tz_unconstrained;\nFUNCTION dbtimezone RETURN\
  \ varchar2;\nFUNCTION sessiontimezone RETURN varchar2;\nFUNCTION localtimestamp\
  \ RETURN timestamp_unconstrained;\nFUNCTION localtime RETURN time_unconstrained;\n\
  function TO_TIMESTAMP (RIGHT DATE) return TIMESTAMP_UNCONSTRAINED;\npragma BUILTIN('TO_TIMESTAMP',\
  \ 0, 15, 17);\nfunction '+'(\n    LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n    RIGHT yminterval_unconstrained\n\
  \  ) return TIMESTAMP_LTZ_UNCONSTRAINED;\nfunction '+'(\n    LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n\
  \    RIGHT dsinterval_unconstrained\n  ) return TIMESTAMP_LTZ_UNCONSTRAINED;\nfunction\
  \ '+'(\n    LEFT yminterval_unconstrained,\n    RIGHT TIMESTAMP_LTZ_UNCONSTRAINED\n\
  \  ) return TIMESTAMP_LTZ_UNCONSTRAINED;\nfunction '+'(\n    LEFT dsinterval_unconstrained,\n\
  \    RIGHT TIMESTAMP_LTZ_UNCONSTRAINED\n  ) return TIMESTAMP_LTZ_UNCONSTRAINED;\n\
  function '-'(\n    LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n    RIGHT yminterval_unconstrained\n\
  \  ) return TIMESTAMP_LTZ_UNCONSTRAINED;\nfunction '-'(\n    LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n\
  \    RIGHT dsinterval_unconstrained\n  ) return TIMESTAMP_LTZ_UNCONSTRAINED;\nfunction\
  \ \" SYS$DSINTERVALSUBTRACT\"(\n    LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n    RIGHT\
  \ TIMESTAMP_LTZ_UNCONSTRAINED\n  ) return dsinterval_unconstrained;\nfunction \"\
  \ SYS$YMINTERVALSUBTRACT\"(\n    LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n    RIGHT TIMESTAMP_LTZ_UNCONSTRAINED\n\
  \  ) return yminterval_unconstrained;\nfunction '-'(\n    LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n\
  \    RIGHT TIMESTAMP_LTZ_UNCONSTRAINED\n  ) return dsinterval_unconstrained;\nfunction\
  \ '=' (\n    LEFT TIMESTAMP_TZ_UNCONSTRAINED,\n    RIGHT TIMESTAMP_TZ_UNCONSTRAINED\n\
  \  ) return BOOLEAN;\nfunction '!=' (\n    LEFT TIMESTAMP_TZ_UNCONSTRAINED,\n  \
  \  RIGHT TIMESTAMP_TZ_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '<' (\n    LEFT\
  \ TIMESTAMP_TZ_UNCONSTRAINED,\n    RIGHT TIMESTAMP_TZ_UNCONSTRAINED\n  ) return\
  \ BOOLEAN;\nfunction '<=' (\n    LEFT TIMESTAMP_TZ_UNCONSTRAINED,\n    RIGHT TIMESTAMP_TZ_UNCONSTRAINED\n\
  \  ) return BOOLEAN;\nfunction '>' (\n    LEFT TIMESTAMP_TZ_UNCONSTRAINED,\n   \
  \ RIGHT TIMESTAMP_TZ_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '>=' (\n    LEFT\
  \ TIMESTAMP_TZ_UNCONSTRAINED,\n    RIGHT TIMESTAMP_TZ_UNCONSTRAINED\n  ) return\
  \ BOOLEAN;\nfunction '=' (\n    LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n    RIGHT TIMESTAMP_LTZ_UNCONSTRAINED\n\
  \  ) return BOOLEAN;\nfunction '!=' (\n    LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n \
  \   RIGHT TIMESTAMP_LTZ_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '<' (\n   \
  \ LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n    RIGHT TIMESTAMP_LTZ_UNCONSTRAINED\n  )\
  \ return BOOLEAN;\nfunction '<=' (\n    LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n    RIGHT\
  \ TIMESTAMP_LTZ_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '>' (\n    LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n\
  \    RIGHT TIMESTAMP_LTZ_UNCONSTRAINED\n  ) return BOOLEAN;\nfunction '>=' (\n \
  \   LEFT TIMESTAMP_LTZ_UNCONSTRAINED,\n    RIGHT TIMESTAMP_LTZ_UNCONSTRAINED\n \
  \ ) return BOOLEAN;\nfunction SYS_LITERALTOYMINTERVAL(numerator varchar2, units\
  \ varchar2) return YMINTERVAL_UNCONSTRAINED;\nfunction SYS_LITERALTODSINTERVAL(numerator\
  \ varchar2, units varchar2) return DSINTERVAL_UNCONSTRAINED;\nfunction SYS_LITERALTOTIME(numerator\
  \ varchar2) return TIME_UNCONSTRAINED;\nfunction SYS_LITERALTOTZTIME(numerator varchar2)\
  \ return TIME_TZ_UNCONSTRAINED;\nfunction SYS_LITERALTOTIMESTAMP(numerator varchar2)\
  \ return TIMESTAMP_UNCONSTRAINED;\nfunction SYS_LITERALTOTZTIMESTAMP(numerator varchar2)\
  \ return TIMESTAMP_TZ_UNCONSTRAINED;\nfunction SYS_LITERALTODATE(numerator varchar2)\
  \ return DATE;\n-- Explicit conversions between date and datetime\n  function TO_TIMESTAMP(ARG\
  \ TIMESTAMP_LTZ_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;\npragma BUILTIN('TO_TIMESTAMP',\
  \ 0, 15, 24);\nfunction TO_TIMESTAMP_TZ(ARG DATE) return TIMESTAMP_TZ_UNCONSTRAINED;\n\
  pragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 27);\nfunction TO_TIMESTAMP_TZ(ARG TIMESTAMP_LTZ_UNCONSTRAINED)\
  \ return TIMESTAMP_TZ_UNCONSTRAINED;\npragma BUILTIN('TO_TIMESTAMP_TZ', 0, 15, 26);\n\
  -- IS [NOT] NULL / NVL for datetime\n  function 'IS NULL' (b TIME_UNCONSTRAINED)\
  \ return BOOLEAN;\nfunction 'IS NOT NULL' (b TIME_UNCONSTRAINED) return BOOLEAN;\n\
  function NVL (\n    b1 TIME_UNCONSTRAINED,\n    b2 TIME_UNCONSTRAINED\n  ) return\
  \ TIME_UNCONSTRAINED;\nfunction 'IS NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;\n\
  function 'IS NOT NULL' (b TIME_TZ_UNCONSTRAINED) return BOOLEAN;\nfunction NVL (\n\
  \    b1 TIME_TZ_UNCONSTRAINED,\n    b2 TIME_TZ_UNCONSTRAINED\n  ) return TIME_TZ_UNCONSTRAINED;\n\
  function 'IS NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;\nfunction 'IS NOT\
  \ NULL' (b TIMESTAMP_UNCONSTRAINED) return BOOLEAN;\nfunction NVL (\n    b1 TIMESTAMP_UNCONSTRAINED,\n\
  \    b2 TIMESTAMP_UNCONSTRAINED\n  ) return TIMESTAMP_UNCONSTRAINED;\nfunction 'IS\
  \ NULL' (b TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;\nfunction 'IS NOT NULL' (b\
  \ TIMESTAMP_TZ_UNCONSTRAINED) return BOOLEAN;\nfunction NVL (\n    b1 TIMESTAMP_TZ_UNCONSTRAINED,\n\
  \    b2 TIMESTAMP_TZ_UNCONSTRAINED\n  ) return TIMESTAMP_TZ_UNCONSTRAINED;\nfunction\
  \ 'IS NULL' (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;\nfunction 'IS NOT NULL'\
  \ (b TIMESTAMP_LTZ_UNCONSTRAINED) return BOOLEAN;\nfunction NVL (\n    b1 TIMESTAMP_LTZ_UNCONSTRAINED,\n\
  \    b2 TIMESTAMP_LTZ_UNCONSTRAINED\n  ) return TIMESTAMP_LTZ_UNCONSTRAINED;\nfunction\
  \ 'IS NULL' (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;\nfunction 'IS NOT NULL'\
  \ (b YMINTERVAL_UNCONSTRAINED) return BOOLEAN;\nfunction NVL (\n    b1 YMINTERVAL_UNCONSTRAINED,\n\
  \    b2 YMINTERVAL_UNCONSTRAINED\n  ) return YMINTERVAL_UNCONSTRAINED;\nfunction\
  \ 'IS NULL' (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;\nfunction 'IS NOT NULL'\
  \ (b DSINTERVAL_UNCONSTRAINED) return BOOLEAN;\nfunction NVL (\n    b1 DSINTERVAL_UNCONSTRAINED,\n\
  \    b2 DSINTERVAL_UNCONSTRAINED\n  ) return DSINTERVAL_UNCONSTRAINED;\nfunction\
  \ \" SYS$EXTRACT_FROM\" (T TIME_UNCONSTRAINED, FIELD VARCHAR2) return NUMBER;\n\
  function \" SYS$EXTRACT_FROM\" (T TIME_TZ_UNCONSTRAINED, FIELD varchar2) return\
  \ NUMBER;\nfunction \" SYS$EXTRACT_FROM\" (T TIMESTAMP_UNCONSTRAINED, FIELD VARCHAR2)\
  \ return NUMBER;\nfunction \" SYS$EXTRACT_FROM\" (T TIMESTAMP_TZ_UNCONSTRAINED,\
  \ FIELD VARCHAR2) return NUMBER;\nfunction \" SYS$EXTRACT_FROM\" (T TIMESTAMP_LTZ_UNCONSTRAINED,\
  \ FIELD varchar2) return NUMBER;\nfunction \" SYS$EXTRACT_FROM\" (T DATE, FIELD\
  \ VARCHAR2) return NUMBER;\nfunction \" SYS$EXTRACT_FROM\" (I YMINTERVAL_UNCONSTRAINED,\
  \ FIELD VARCHAR2) return NUMBER;\nfunction \" SYS$EXTRACT_FROM\" (I DSINTERVAL_UNCONSTRAINED,\
  \ FIELD VARCHAR2) return NUMBER;\n-- ##########      8.2 LOB Built-in Functions\
  \       ######## --\n  -- LENGTH --\n  function LENGTH(\n    ch CLOB CHARACTER\n\
  \    SET\n      ANY_CS\n  ) return integer;\npragma FIPSFLAG('LENGTH', 1452);\n\
  function LENGTHB(\n    ch CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return integer;\n\
  pragma FIPSFLAG('LENGTHB', 1452);\nfunction LENGTH(bl BLOB) return integer;\npragma\
  \ FIPSFLAG('LENGTH', 1452);\nfunction LENGTHB(bl BLOB) return integer;\npragma FIPSFLAG('LENGTHB',\
  \ 1452);\n-- SUBSTR --\n  function SUBSTR(\n    STR1 CLOB CHARACTER\n    SET\n \
  \     ANY_CS,\n      POS INTEGER,\n      LEN INTEGER: = 18446744073709551615\n \
  \ ) return CLOB CHARACTER\nSET\n  STR1 % CHARSET;\npragma FIPSFLAG('SUBSTR', 1452);\n\
  function SUBSTRB(\n    STR1 CLOB CHARACTER\n    SET\n      ANY_CS,\n      POS INTEGER,\n\
  \      LEN INTEGER: = 18446744073709551615\n  ) return CLOB CHARACTER\nSET\n  STR1\
  \ % CHARSET;\npragma FIPSFLAG('SUBSTRB', 1452);\n-- INSTR --\n  function INSTR(\n\
  \    STR1 CLOB CHARACTER\n    SET\n      ANY_CS,\n      STR2 CLOB CHARACTER\n  \
  \  SET\n      STR1 % CHARSET,\n      POS INTEGER: = 1,\n      NTH INTEGER: = 1\n\
  \  ) return INTEGER;\npragma FIPSFLAG('INSTR', 1452);\nfunction INSTRB(\n    STR1\
  \ CLOB CHARACTER\n    SET\n      ANY_CS,\n      STR2 CLOB CHARACTER\n    SET\n \
  \     STR1 % CHARSET,\n      POS INTEGER: = 1,\n      NTH INTEGER: = 1\n  ) return\
  \ INTEGER;\npragma FIPSFLAG('INSTRB', 1452);\n-- CONCAT --\n  function '||' (\n\
  \    LEFT CLOB CHARACTER\n    SET\n      ANY_CS,\n      RIGHT CLOB CHARACTER\n \
  \   SET\n      ANY_CS\n  ) return CLOB CHARACTER\nSET\n  LEFT % CHARSET;\npragma\
  \ FIPSFLAG('||', 1454);\nfunction CONCAT(\n    LEFT CLOB CHARACTER\n    SET\n  \
  \    ANY_CS,\n      RIGHT CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return CLOB\
  \ CHARACTER\nSET\n  LEFT % CHARSET;\npragma FIPSFLAG(CONCAT, 1454);\n-- UPPER --\n\
  \  function UPPER(\n    ch CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return CLOB\
  \ CHARACTER\nSET\n  ch % CHARSET;\npragma FIPSFLAG('UPPER', 1452);\n-- LOWER --\n\
  \  function LOWER(\n    ch CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return CLOB\
  \ CHARACTER\nSET\n  ch % CHARSET;\npragma FIPSFLAG('LOWER', 1452);\n-- LPAD --\n\
  \  function LPAD(\n    STR1 CLOB CHARACTER\n    SET\n      ANY_CS,\n      LEN integer,\n\
  \      PAD CLOB CHARACTER\n    SET\n      STR1 % CHARSET\n  ) return CLOB CHARACTER\n\
  SET\n  STR1 % CHARSET;\npragma FIPSFLAG('LPAD', 1452);\nfunction LPAD(\n    STR1\
  \ CLOB CHARACTER\n    SET\n      ANY_CS,\n      LEN integer\n  ) return CLOB CHARACTER\n\
  SET\n  STR1 % CHARSET;\npragma FIPSFLAG('LPAD', 1452);\n-- RPAD --\n  function RPAD(\n\
  \    STR1 CLOB CHARACTER\n    SET\n      ANY_CS,\n      LEN integer,\n      PAD\
  \ CLOB CHARACTER\n    SET\n      STR1 % CHARSET\n  ) return CLOB CHARACTER\nSET\n\
  \  STR1 % CHARSET;\npragma FIPSFLAG('RPAD', 1452);\nfunction RPAD(\n    STR1 CLOB\
  \ CHARACTER\n    SET\n      ANY_CS,\n      LEN integer\n  ) return CLOB CHARACTER\n\
  SET\n  STR1 % CHARSET;\npragma FIPSFLAG('RPAD', 1452);\n-- LTRIM --\n  function\
  \ LTRIM(\n    STR1 CLOB CHARACTER\n    SET\n      ANY_CS,\n      TSET CLOB CHARACTER\n\
  \    SET\n      STR1 % CHARSET\n  ) return CLOB CHARACTER\nSET\n  STR1 % CHARSET;\n\
  pragma FIPSFLAG('LTRIM', 1452);\nfunction LTRIM(\n    STR1 CLOB CHARACTER\n    SET\n\
  \      ANY_CS\n  ) return CLOB CHARACTER\nSET\n  STR1 % CHARSET;\npragma FIPSFLAG('LTRIM',\
  \ 1452);\n-- RTRIM --\n  function RTRIM(\n    STR1 CLOB CHARACTER\n    SET\n   \
  \   ANY_CS,\n      TSET CLOB CHARACTER\n    SET\n      STR1 % CHARSET\n  ) return\
  \ CLOB CHARACTER\nSET\n  STR1 % CHARSET;\npragma FIPSFLAG('RTRIM', 1452);\nfunction\
  \ RTRIM(\n    STR1 CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return CLOB CHARACTER\n\
  SET\n  STR1 % CHARSET;\npragma FIPSFLAG('RTRIM', 1452);\n-- TRIM --\n  function\
  \ TRIM(\n    v CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return CLOB CHARACTER\n\
  SET\n  v % CHARSET;\n-- This is for TRIM(x). No trim set.\n  function \" SYS$STANDARD_TRIM\"\
  \ (\n    v CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return CLOB CHARACTER\nSET\n\
  \  v % CHARSET;\n-- This is for TRIM(LEADING/TRAILING FROM x). No trim set.\n  function\
  \ \" SYS$STANDARD_TRIM\" (\n    STR1 CLOB CHARACTER\n    SET\n      ANY_CS,\n  \
  \    TRFLAG PLS_INTEGER\n  ) return CLOB CHARACTER\nSET\n  STR1 % CHARSET;\n-- General\
  \ TRIM. LEADING, TRAILING and BOTH options as 3rd argument.\n  -- This one takes\
  \ a trim set.\n  function \" SYS$STANDARD_TRIM\" (\n    STR1 CLOB CHARACTER\n  \
  \  SET\n      ANY_CS,\n      TSET CLOB CHARACTER\n    SET\n      STR1 % CHARSET,\n\
  \      TRFLAG PLS_INTEGER\n  ) return CLOB CHARACTER\nSET\n  STR1 % CHARSET;\n--\
  \ LIKE --\n  function 'LIKE' (\n    str CLOB CHARACTER\n    SET\n      ANY_CS,\n\
  \      pat CLOB CHARACTER\n    SET\n      str % CHARSET\n  ) return BOOLEAN;\nfunction\
  \ 'NOT_LIKE' (\n    str CLOB CHARACTER\n    SET\n      ANY_CS,\n      pat CLOB CHARACTER\n\
  \    SET\n      str % CHARSET\n  ) return BOOLEAN;\nfunction 'LIKE' (\n    str CLOB\
  \ CHARACTER\n    SET\n      ANY_CS,\n      pat CLOB CHARACTER\n    SET\n      str\
  \ % CHARSET,\n      esc VARCHAR2 CHARACTER\n    SET\n      str % CHARSET\n  ) return\
  \ BOOLEAN;\nfunction 'NOT_LIKE' (\n    str CLOB CHARACTER\n    SET\n      ANY_CS,\n\
  \      pat CLOB CHARACTER\n    SET\n      str % CHARSET,\n      esc VARCHAR2 CHARACTER\n\
  \    SET\n      str % CHARSET\n  ) return BOOLEAN;\n-- NVL --\n  function NVL(\n\
  \    s1 CLOB CHARACTER\n    SET\n      ANY_CS,\n      s2 CLOB CHARACTER\n    SET\n\
  \      s1 % CHARSET\n  ) return CLOB CHARACTER\nSET\n  s1 % CHARSET;\npragma FIPSFLAG('NVL',\
  \ 1452);\n-- REPLACE --\n  function REPLACE(\n    SRCSTR CLOB CHARACTER\n    SET\n\
  \      ANY_CS,\n      OLDSUB CLOB CHARACTER\n    SET\n      SRCSTR % CHARSET,\n\
  \      NEWSUB CLOB CHARACTER\n    SET\n      SRCSTR % CHARSET: = NULL\n  ) return\
  \ CLOB CHARACTER\nSET\n  SRCSTR % CHARSET;\npragma FIPSFLAG('REPLACE', 1452);\n\
  -- LOB RELATIONAL OPERATORS --\n  Function '=' (\n    LEFT CLOB CHARACTER\n    SET\n\
  \      ANY_CS,\n      RIGHT CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return BOOLEAN;\n\
  Function '!=' (\n    LEFT CLOB CHARACTER\n    SET\n      ANY_CS,\n      RIGHT CLOB\
  \ CHARACTER\n    SET\n      ANY_CS\n  ) return BOOLEAN;\nFunction '>' (\n    LEFT\
  \ CLOB CHARACTER\n    SET\n      ANY_CS,\n      RIGHT CLOB CHARACTER\n    SET\n\
  \      ANY_CS\n  ) return BOOLEAN;\nFunction '<' (\n    LEFT CLOB CHARACTER\n  \
  \  SET\n      ANY_CS,\n      RIGHT CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return\
  \ BOOLEAN;\nFunction '>=' (\n    LEFT CLOB CHARACTER\n    SET\n      ANY_CS,\n \
  \     RIGHT CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return BOOLEAN;\nFunction\
  \ '<=' (\n    LEFT CLOB CHARACTER\n    SET\n      ANY_CS,\n      RIGHT CLOB CHARACTER\n\
  \    SET\n      ANY_CS\n  ) return BOOLEAN;\nFunction '=' (\n    LEFT CLOB CHARACTER\n\
  \    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n\
  \  ) return BOOLEAN;\nFunction '!=' (\n    LEFT CLOB CHARACTER\n    SET\n      ANY_CS,\n\
  \      RIGHT VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return BOOLEAN;\nFunction\
  \ '>' (\n    LEFT CLOB CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS\n  ) return BOOLEAN;\nFunction '<' (\n    LEFT CLOB CHARACTER\n\
  \    SET\n      ANY_CS,\n      RIGHT VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n\
  \  ) return BOOLEAN;\nFunction '>=' (\n    LEFT CLOB CHARACTER\n    SET\n      ANY_CS,\n\
  \      RIGHT VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return BOOLEAN;\nFunction\
  \ '<=' (\n    LEFT CLOB CHARACTER\n    SET\n      ANY_CS,\n      RIGHT VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS\n  ) return BOOLEAN;\nFunction '=' (\n    LEFT\
  \ VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT CLOB CHARACTER\n    SET\n\
  \      ANY_CS\n  ) return BOOLEAN;\nFunction '!=' (\n    LEFT VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      RIGHT CLOB CHARACTER\n    SET\n      ANY_CS\n  )\
  \ return BOOLEAN;\nFunction '>' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      RIGHT CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return BOOLEAN;\nFunction\
  \ '<' (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      RIGHT CLOB CHARACTER\n\
  \    SET\n      ANY_CS\n  ) return BOOLEAN;\nFunction '>=' (\n    LEFT VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS,\n      RIGHT CLOB CHARACTER\n    SET\n     \
  \ ANY_CS\n  ) return BOOLEAN;\nFunction '<=' (\n    LEFT VARCHAR2 CHARACTER\n  \
  \  SET\n      ANY_CS,\n      RIGHT CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return\
  \ BOOLEAN;\n  /* LOB-related conversion functions */\n  function TO_CLOB(\n    RIGHT\
  \ VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return CLOB;\npragma BUILTIN('TO_CLOB',\
  \ 0, 15, 29);\n-- OPC_CVT_CHR2CLB\n  function TO_BLOB(RIGHT RAW) return BLOB;\n\
  pragma BUILTIN('TO_BLOB', 0, 15, 30);\n-- OPC_CVT_RAW2BLB\n  function TO_RAW(RIGHT\
  \ BLOB) return RAW;\npragma BUILTIN('TO_RAW', 0, 15, 32);\n-- OPC_CVT_BLB2RAW\n\
  \  -- ####### end of 8.2 LOB Built-in Functions  ######## --\n  function NULLIF(v1\
  \ VARCHAR2, v2 VARCHAR2) return VARCHAR2;\nfunction NULLIF(v1 BOOLEAN, v2 BOOLEAN)\
  \ return VARCHAR2;\nfunction NULLIF(a1 \"<ADT_1>\", a2 \"<ADT_1>\") return VARCHAR2;\n\
  function COALESCE return VARCHAR2;\n  /* Daylight Saving Time Functions */\n  FUNCTION\
  \ tz_offset(region VARCHAR2) RETURN VARCHAR2;\nFUNCTION from_tz(t TIMESTAMP_UNCONSTRAINED,\
  \ timezone VARCHAR2) RETURN timestamp_tz_unconstrained;\nfunction \" SYS$EXTRACT_STRING_FROM\"\
  \ (T TIME_TZ_UNCONSTRAINED, FIELD varchar2) return VARCHAR2;\nfunction \" SYS$EXTRACT_STRING_FROM\"\
  \ (T TIMESTAMP_TZ_UNCONSTRAINED, FIELD VARCHAR2) return VARCHAR2;\nfunction \" SYS$EXTRACT_STRING_FROM\"\
  \ (T TIMESTAMP_LTZ_UNCONSTRAINED, FIELD varchar2) return VARCHAR2;\nfunction INSTR2(\n\
  \    STR1 VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      STR2 VARCHAR2 CHARACTER\n\
  \    SET\n      STR1 % CHARSET,\n      POS PLS_INTEGER: = 1,\n      NTH POSITIVE:\
  \ = 1\n  ) return PLS_INTEGER;\npragma FIPSFLAG('INSTR2', 1452);\nfunction INSTR4(\n\
  \    STR1 VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      STR2 VARCHAR2 CHARACTER\n\
  \    SET\n      STR1 % CHARSET,\n      POS PLS_INTEGER: = 1,\n      NTH POSITIVE:\
  \ = 1\n  ) return PLS_INTEGER;\npragma FIPSFLAG('INSTR4', 1452);\nfunction INSTRC(\n\
  \    STR1 VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      STR2 VARCHAR2 CHARACTER\n\
  \    SET\n      STR1 % CHARSET,\n      POS PLS_INTEGER: = 1,\n      NTH POSITIVE:\
  \ = 1\n  ) return PLS_INTEGER;\npragma FIPSFLAG('INSTRC', 1452);\nfunction LENGTH2(\n\
  \    ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return natural;\npragma FIPSFLAG('LENGTH2',\
  \ 1452);\nfunction LENGTH4(\n    ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n\
  \  ) return natural;\npragma FIPSFLAG('LENGTH4', 1452);\nfunction LENGTHC(\n   \
  \ ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return natural;\npragma FIPSFLAG('LENGTHC',\
  \ 1452);\nfunction 'LIKE2' (\n    str VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      pat VARCHAR2 CHARACTER\n    SET\n      str % CHARSET\n  ) return BOOLEAN;\n\
  function 'NOT_LIKE2' (\n    str VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n   \
  \   pat VARCHAR2 CHARACTER\n    SET\n      str % CHARSET\n  ) return BOOLEAN;\n\
  function 'LIKE2' (\n    str VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      pat\
  \ VARCHAR2 CHARACTER\n    SET\n      str % CHARSET,\n      esc VARCHAR2 CHARACTER\n\
  \    SET\n      str % CHARSET\n  ) return BOOLEAN;\nfunction 'NOT_LIKE2' (\n   \
  \ str VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      pat VARCHAR2 CHARACTER\n\
  \    SET\n      str % CHARSET,\n      esc VARCHAR2 CHARACTER\n    SET\n      str\
  \ % CHARSET\n  ) return BOOLEAN;\nfunction 'LIKE4' (\n    str VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n      str % CHARSET\n\
  \  ) return BOOLEAN;\nfunction 'NOT_LIKE4' (\n    str VARCHAR2 CHARACTER\n    SET\n\
  \      ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n      str % CHARSET\n  )\
  \ return BOOLEAN;\nfunction 'LIKE4' (\n    str VARCHAR2 CHARACTER\n    SET\n   \
  \   ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n      str % CHARSET,\n     \
  \ esc VARCHAR2 CHARACTER\n    SET\n      str % CHARSET\n  ) return BOOLEAN;\nfunction\
  \ 'NOT_LIKE4' (\n    str VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      pat VARCHAR2\
  \ CHARACTER\n    SET\n      str % CHARSET,\n      esc VARCHAR2 CHARACTER\n    SET\n\
  \      str % CHARSET\n  ) return BOOLEAN;\nfunction 'LIKEC' (\n    str VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n   \
  \   str % CHARSET\n  ) return BOOLEAN;\nfunction 'NOT_LIKEC' (\n    str VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n   \
  \   str % CHARSET\n  ) return BOOLEAN;\nfunction 'LIKEC' (\n    str VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      pat VARCHAR2 CHARACTER\n    SET\n      str % CHARSET,\n\
  \      esc VARCHAR2 CHARACTER\n    SET\n      str % CHARSET\n  ) return BOOLEAN;\n\
  function 'NOT_LIKEC' (\n    str VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n   \
  \   pat VARCHAR2 CHARACTER\n    SET\n      str % CHARSET,\n      esc VARCHAR2 CHARACTER\n\
  \    SET\n      str % CHARSET\n  ) return BOOLEAN;\nfunction SUBSTR2(\n    STR1\
  \ VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      POS PLS_INTEGER,\n      LEN\
  \ PLS_INTEGER: = 2147483647\n  ) return VARCHAR2 CHARACTER\nSET\n  STR1 % CHARSET;\n\
  pragma FIPSFLAG('SUBSTR2', 1452);\nfunction SUBSTR4(\n    STR1 VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      POS PLS_INTEGER,\n      LEN PLS_INTEGER: = 2147483647\n\
  \  ) return VARCHAR2 CHARACTER\nSET\n  STR1 % CHARSET;\npragma FIPSFLAG('SUBSTR4',\
  \ 1452);\nfunction SUBSTRC(\n    STR1 VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      POS PLS_INTEGER,\n      LEN PLS_INTEGER: = 2147483647\n  ) return VARCHAR2\
  \ CHARACTER\nSET\n  STR1 % CHARSET;\npragma FIPSFLAG('SUBSTRC', 1452);\n  /****\
  \ char <--> nchar conversion functions in Unicode project ********/\n  function\
  \ TO_NCHAR(RIGHT NVARCHAR2) return NVARCHAR2;\npragma BUILTIN('TO_NCHAR', 14, 0,\
  \ 2);\nfunction TO_NCLOB(\n    cl CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return\
  \ NCLOB;\nfunction TO_CLOB(\n    cl CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return\
  \ CLOB;\nfunction TO_NCLOB(\n    RIGHT VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n\
  \  ) return NCLOB;\npragma BUILTIN('TO_NCLOB', 0, 15, 29);\n-- OPC_CVT_CHR2CLB\n\
  \  /* convert to either CLOB or NCLOB respectively if parm is char or nchar */\n\
  \  function TO_ANYLOB(\n    RIGHT VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  )\
  \ return CLOB CHARACTER\nSET\n  RIGHT % CHARSET;\npragma BUILTIN('TO_ANYLOB', 0,\
  \ 15, 29);\n-- OPC_CVT_CHR2CLB\n  /* Followings are the same builtin op codes as\
  \ without N prefix functions,\n  \n     * implementation relys on impilcit conversion\
  \ MCODEs\n  \n     */\n  function TO_NCHAR (LEFT DATE, FORMAT NVARCHAR2) return\
  \ NVARCHAR2;\npragma BUILTIN('TO_NCHAR', 41, 12, 19);\n-- PEMS_DATE, DAT_CNV_CHR1\n\
  \  pragma FIPSFLAG('TO_NCHAR', 1450);\nfunction TO_NCHAR (LEFT NUMBER, FORMAT NVARCHAR2)\
  \ return NVARCHAR2;\npragma BUILTIN('TO_NCHAR', 41, 2, 14);\n-- PEMS_NUMBER, NUM_CNV_CHR\n\
  \  function NHEXTORAW (c NVARCHAR2) return RAW;\npragma builtin('NHEXTORAW', 1,\
  \ 23, 1);\nfunction RAWTONHEX (r RAW) return NVARCHAR2;\npragma builtin('RAWTONHEX',\
  \ 1, 23, 2);\nfunction NCHARTOROWID (str NVARCHAR2) return ROWID;\npragma builtin('NCHARTOROWID',\
  \ 1, 0, 1);\nfunction ROWIDTONCHAR (str ROWID) return NVARCHAR2;\npragma builtin('ROWIDTONCHAR',\
  \ 1, 0, 1);\nfunction NCHR(n integer) return NVARCHAR2;\n  /* implemented by icd\
  \ calls as the same as TO_CHAR */\n  function TO_NCHAR(left date, format nvarchar2,\
  \ parms nvarchar2) return nvarchar2;\nfunction TO_NCHAR(left number, format nvarchar2,\
  \ parms nvarchar2) return nvarchar2;\n  /* implemented as a icd call, return TRUE\
  \ if nchar, otherwise FALSE */\n  function ISNCHAR(\n    c VARCHAR2 character\n\
  \    set\n      any_cs\n  ) return boolean;\n  /************ end of char <--> nchar\
  \ conversion functions ************/\n  /* Create overloads for all standard functions\
  \ that work with <ADT_1> for\n  \n       <OPAQUE_1> */\n  function '=' (LEFT \"\
  <OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\npragma BUILTIN('=', 1, 1, 1);\n\
  pragma FIPSFLAG('=', 1450);\nfunction '!=' (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\"\
  ) return BOOLEAN;\npragma BUILTIN('!=', 1, 1, 1);\npragma FIPSFLAG('!=', 1450);\n\
  function '<' (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\npragma\
  \ BUILTIN('<', 1, 1, 1);\npragma FIPSFLAG('<', 1450);\nfunction '<=' (LEFT \"<OPAQUE_1>\"\
  , RIGHT \"<OPAQUE_1>\") return BOOLEAN;\npragma BUILTIN('<=', 1, 1, 1);\npragma\
  \ FIPSFLAG('<=', 1450);\nfunction '>' (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\"\
  ) return BOOLEAN;\npragma BUILTIN('>', 1, 1, 1);\npragma FIPSFLAG('>', 1450);\n\
  function '>=' (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\npragma\
  \ BUILTIN('>=', 1, 1, 1);\npragma FIPSFLAG('>=', 1450);\nfunction '=ANY' (LEFT \"\
  <OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\nfunction '!=ANY' (LEFT \"<OPAQUE_1>\"\
  , RIGHT \"<OPAQUE_1>\") return BOOLEAN;\nfunction '<ANY' (LEFT \"<OPAQUE_1>\", RIGHT\
  \ \"<OPAQUE_1>\") return BOOLEAN;\nfunction '<=ANY' (LEFT \"<OPAQUE_1>\", RIGHT\
  \ \"<OPAQUE_1>\") return BOOLEAN;\nfunction '>ANY' (LEFT \"<OPAQUE_1>\", RIGHT \"\
  <OPAQUE_1>\") return BOOLEAN;\nfunction '>=ANY' (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\"\
  ) return BOOLEAN;\nfunction '=ALL' (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return\
  \ BOOLEAN;\nfunction '!=ALL' (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return\
  \ BOOLEAN;\nfunction '<ALL' (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\n\
  function '<=ALL' (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\nfunction\
  \ '>ALL' (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\nfunction '>=ALL'\
  \ (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\nfunction '=SOME'\
  \ (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\nfunction '!=SOME'\
  \ (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\nfunction '<SOME'\
  \ (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\nfunction '<=SOME'\
  \ (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\nfunction '>SOME'\
  \ (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\nfunction '>=SOME'\
  \ (LEFT \"<OPAQUE_1>\", RIGHT \"<OPAQUE_1>\") return BOOLEAN;\n-- Outer Join\n \
  \ function '(+)' (colname \"<OPAQUE_1>\") return \"<OPAQUE_1>\";\npragma FIPSFLAG('(+)',\
  \ 1450);\n--  GREATEST and LEAST are not yet supported for ADTs in 8.0.2.\n  --\
  \  function GREATEST (pattern \"<OPAQUE_1>\") return \"<OPAQUE_1>\";\n  --    pragma\
  \ BUILTIN('GREATEST', 1, 1, 1);\n  --  function LEAST (pattern \"<OPAQUE_1>\") return\
  \ \"<OPAQUE_1>\";\n  --    pragma BUILTIN('LEAST', 1, 1, 1);\n  function DECODE\
  \ (\n    expr \"<OPAQUE_1>\",\n    pat \"<OPAQUE_1>\",\n    res \"<OPAQUE_1>\"\n\
  \  ) return \"<OPAQUE_1>\";\npragma BUILTIN('DECODE', 1, 1, 1);\nfunction 'IS NULL'\
  \ (B \"<OPAQUE_1>\") return BOOLEAN;\npragma BUILTIN('IS NULL', 0, 3, 0);\npragma\
  \ FIPSFLAG('IS NULL', 1450);\nfunction 'IS NOT NULL' (B \"<OPAQUE_1>\") return BOOLEAN;\n\
  pragma BUILTIN('IS NOT NULL', 0, 3, 50);\npragma FIPSFLAG('IS NOT NULL', 1450);\n\
  function NVL (B1 \"<OPAQUE_1>\", B2 \"<OPAQUE_1>\") return \"<OPAQUE_1>\";\npragma\
  \ FIPSFLAG('NVL', 1450);\n--  REFs to opaques are not supported yet.\n  --  function\
  \ VALUE (item \"<ADT_WITH_OID>\") return \"<OPAQUE_1>\";\n  --    pragma BUILTIN('VALUE',\
  \ 1, 1, 1);\n  --    pragma FIPSFLAG('VALUE', 1450);\n  --  function REF (item \"\
  <ADT_WITH_OID>\") return REF \"<OPAQUE_1>\";\n  --    pragma BUILTIN('REF', 1, 1,\
  \ 1);\n  --    pragma FIPSFLAG('REF', 1450);\n  --  function DEREF (r REF \"<OPAQUE_1>\"\
  ) return \"<OPAQUE_1>\";\n  --    pragma BUILTIN('DEREF', 1, 1, 1);\n  --    pragma\
  \ FIPSFLAG('DEREF', 1450);\n  -- overloadings for REF OPAQUE\n  --  function 'IS\
  \ NULL' (B REF \"<OPAQUE_1>\") return BOOLEAN;\n  --    pragma BUILTIN('IS NULL',\
  \ 0, 3, 0);\n  --    pragma FIPSFLAG('IS NULL', 1450);\n  --  function 'IS NOT NULL'\
  \ (B REF \"<OPAQUE_1>\") return BOOLEAN;\n  --    pragma FIPSFLAG('IS NOT NULL',\
  \ 1450);\n  --  function 'IS DANGLING' (B REF \"<OPAQUE_1>\") return BOOLEAN;\n\
  \  --    pragma BUILTIN('IS DANGLING', 1, 1, 1);\n  --    pragma FIPSFLAG('IS DANGLING',\
  \ 1450);\n  --  function 'IS NOT DANGLING' (B REF \"<OPAQUE_1>\") return BOOLEAN;\n\
  \  --    pragma BUILTIN('IS NOT DANGLING', 1, 1, 1);\n  --    pragma FIPSFLAG('IS\
  \ NOT DANGLING', 1450);\n  --  function NVL (B1 REF \"<OPAQUE_1>\", B2 REF \"<OPAQUE_1>\"\
  )\n  --    return REF \"<OPAQUE_1>\";\n  --    pragma FIPSFLAG('NVL', 1450);\n \
  \ --  function '='  (LEFT REF \"<OPAQUE_1>\", RIGHT REF \"<OPAQUE_1>\")\n  --  \
  \  return BOOLEAN;\n  --    pragma BUILTIN('=', 0, 3, 1);\n  --    pragma FIPSFLAG('=',\
  \ 1450);\n  --  function '!=' (LEFT REF \"<OPAQUE_1>\", RIGHT REF \"<OPAQUE_1>\"\
  )\n  --    return BOOLEAN;\n  --    pragma BUILTIN('!=', 0, 3, 2);\n  --    pragma\
  \ FIPSFLAG('!=', 1450);\n  function GROUPING(a \"<OPAQUE_1>\") return NUMBER;\n\
  function NULLIF(a1 \"<OPAQUE_1>\", a2 \"<OPAQUE_1>\") return VARCHAR2;\nfunction\
  \ GREATEST (pattern TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;\npragma BUILTIN('GREATEST',\
  \ 12, 240, 240);\n-- This is special cased in PH2 -- Pj\n  function GREATEST (pattern\
  \ TIME_TZ_UNCONSTRAINED) return TIME_TZ_UNCONSTRAINED;\npragma BUILTIN('GREATEST',\
  \ 12, 240, 240);\n-- This is special cased in PH2 -- Pj\n  function GREATEST (pattern\
  \ TIMESTAMP_UNCONSTRAINED) return TIMESTAMP_UNCONSTRAINED;\npragma BUILTIN('GREATEST',\
  \ 12, 240, 240);\n-- This is special cased in PH2 -- Pj\n  function GREATEST (pattern\
  \ TIMESTAMP_TZ_UNCONSTRAINED) return TIMESTAMP_TZ_UNCONSTRAINED;\npragma BUILTIN('GREATEST',\
  \ 12, 240, 240);\n-- This is special cased in PH2 -- Pj\n  function GREATEST (pattern\
  \ TIMESTAMP_LTZ_UNCONSTRAINED) return TIMESTAMP_LTZ_UNCONSTRAINED;\npragma BUILTIN('GREATEST',\
  \ 12, 240, 240);\n-- This is special cased in PH2 -- Pj\n  function GREATEST (pattern\
  \ YMINTERVAL_UNCONSTRAINED) return YMINTERVAL_UNCONSTRAINED;\npragma BUILTIN('GREATEST',\
  \ 12, 240, 240);\n-- This is special cased in PH2 -- Pj\n  function GREATEST (pattern\
  \ DSINTERVAL_UNCONSTRAINED) return DSINTERVAL_UNCONSTRAINED;\npragma BUILTIN('GREATEST',\
  \ 12, 240, 240);\n-- This is special cased in PH2 -- Pj\n  function LEAST (pattern\
  \ TIME_UNCONSTRAINED) return TIME_UNCONSTRAINED;\npragma BUILTIN('LEAST', 12, 240,\
  \ 240);\n-- This is special cased in PH2 -- Pj\n  function LEAST (pattern TIME_TZ_UNCONSTRAINED)\
  \ return TIME_TZ_UNCONSTRAINED;\npragma BUILTIN('LEAST', 12, 240, 240);\n-- This\
  \ is special cased in PH2 -- Pj\n  function LEAST (pattern TIMESTAMP_UNCONSTRAINED)\
  \ return TIMESTAMP_UNCONSTRAINED;\npragma BUILTIN('LEAST', 12, 240, 240);\n-- This\
  \ is special cased in PH2 -- Pj\n  function LEAST (pattern TIMESTAMP_TZ_UNCONSTRAINED)\
  \ return TIMESTAMP_TZ_UNCONSTRAINED;\npragma BUILTIN('LEAST', 12, 240, 240);\n--\
  \ This is special cased in PH2 -- Pj\n  function LEAST (pattern TIMESTAMP_LTZ_UNCONSTRAINED)\
  \ return TIMESTAMP_LTZ_UNCONSTRAINED;\npragma BUILTIN('LEAST', 12, 240, 240);\n\
  -- This is special cased in PH2 -- Pj\n  function LEAST (pattern YMINTERVAL_UNCONSTRAINED)\
  \ return YMINTERVAL_UNCONSTRAINED;\npragma BUILTIN('LEAST', 12, 240, 240);\n-- This\
  \ is special cased in PH2 -- Pj\n  function LEAST (pattern DSINTERVAL_UNCONSTRAINED)\
  \ return DSINTERVAL_UNCONSTRAINED;\npragma BUILTIN('LEAST', 12, 240, 240);\n-- This\
  \ is special cased in PH2 -- Pj\n  function TO_CHAR(\n    left TIME_UNCONSTRAINED,\n\
  \    format VARCHAR2,\n    parms VARCHAR2\n  ) return VARCHAR2;\nfunction TO_CHAR(left\
  \ TIME_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;\nfunction TO_CHAR(\n   \
  \ left TIME_TZ_UNCONSTRAINED,\n    format VARCHAR2,\n    parms VARCHAR2\n  ) return\
  \ VARCHAR2;\nfunction TO_CHAR(left TIME_TZ_UNCONSTRAINED, format VARCHAR2) return\
  \ VARCHAR2;\nfunction TO_CHAR(\n    left TIMESTAMP_UNCONSTRAINED,\n    format VARCHAR2,\n\
  \    parms VARCHAR2\n  ) return VARCHAR2;\nfunction TO_CHAR(left TIMESTAMP_UNCONSTRAINED,\
  \ format VARCHAR2) return VARCHAR2;\nfunction TO_CHAR(\n    left TIMESTAMP_TZ_UNCONSTRAINED,\n\
  \    format VARCHAR2,\n    parms VARCHAR2\n  ) return VARCHAR2;\nfunction TO_CHAR(left\
  \ TIMESTAMP_TZ_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;\nfunction TO_CHAR(\n\
  \    left TIMESTAMP_LTZ_UNCONSTRAINED,\n    format VARCHAR2,\n    parms VARCHAR2\n\
  \  ) return VARCHAR2;\nfunction TO_CHAR(\n    left TIMESTAMP_LTZ_UNCONSTRAINED,\n\
  \    format VARCHAR2\n  ) return VARCHAR2;\nfunction TO_CHAR(\n    left YMINTERVAL_UNCONSTRAINED,\n\
  \    format VARCHAR2,\n    parms VARCHAR2\n  ) return VARCHAR2;\nfunction TO_CHAR(left\
  \ YMINTERVAL_UNCONSTRAINED, format VARCHAR2) return VARCHAR2;\nfunction TO_CHAR(\n\
  \    left DSINTERVAL_UNCONSTRAINED,\n    format VARCHAR2,\n    parms VARCHAR2\n\
  \  ) return VARCHAR2;\nfunction TO_CHAR(left DSINTERVAL_UNCONSTRAINED, format VARCHAR2)\
  \ return VARCHAR2;\n-- CONVERT FOR LOB --\n  function CONVERT(\n    SRCSTR CLOB\
  \ CHARACTER\n    SET\n      ANY_CS,\n      DSTCSN VARCHAR2\n  ) return CLOB CHARACTER\n\
  SET\n  SRCSTR % CHARSET;\nfunction CONVERT(\n    SRCSTR CLOB CHARACTER\n    SET\n\
  \      ANY_CS,\n      DSTCSN VARCHAR2,\n      SRCCSN VARCHAR2\n  ) return CLOB CHARACTER\n\
  SET\n  SRCSTR % CHARSET;\n-- NLS_UPPER/NLS_LOWER FOR LOB --\n  function NLS_UPPER(\n\
  \    ch CLOB CHARACTER\n    SET\n      ANY_CS,\n      parms VARCHAR2 CHARACTER\n\
  \    SET\n      ch % CHARSET\n  ) return CLOB CHARACTER\nSET\n  ch % CHARSET;\n\
  pragma FIPSFLAG('NLS_UPPER', 1452);\nfunction NLS_UPPER(\n    ch CLOB CHARACTER\n\
  \    SET\n      ANY_CS\n  ) return CLOB CHARACTER\nSET\n  ch % CHARSET;\npragma\
  \ FIPSFLAG('NLS_UPPER', 1452);\nfunction NLS_LOWER(\n    ch CLOB CHARACTER\n   \
  \ SET\n      ANY_CS,\n      parms VARCHAR2 CHARACTER\n    SET\n      ch % CHARSET\n\
  \  ) return CLOB CHARACTER\nSET\n  ch % CHARSET;\npragma FIPSFLAG('NLS_LOWER', 1452);\n\
  function NLS_LOWER(\n    ch CLOB CHARACTER\n    SET\n      ANY_CS\n  ) return CLOB\
  \ CHARACTER\nSET\n  ch % CHARSET;\npragma FIPSFLAG('NLS_LOWER', 1452);\nfunction\
  \ COMPOSE(\n    ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS\n  ) return varchar2\
  \ character\nset\n  ch % charset;\npragma FIPSFLAG('COMPOSE', 1452);\nfunction DECOMPOSE(\n\
  \    ch VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      canmode in VARCHAR2 DEFAULT\
  \ 'CANONICAL'\n  ) return varchar2 character\nset\n  ch % charset;\npragma FIPSFLAG('DECOMPOSE',\
  \ 1452);\nFUNCTION SYS_EXTRACT_UTC(t timestamp_tz_unconstrained) return TIMESTAMP_UNCONSTRAINED;\n\
  -- Begin REGEXP Support (10iR1) --\n  -- REGEXP_LIKE --\n  function REGEXP_LIKE\
  \ (\n    srcstr VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      pattern VARCHAR2\
  \ CHARACTER\n    SET\n      srcstr % CHARSET,\n      modifier VARCHAR2 DEFAULT NULL\n\
  \  ) return BOOLEAN;\npragma FIPSFLAG('REGEXP_LIKE', 1452);\nfunction REGEXP_LIKE\
  \ (\n    srcstr CLOB CHARACTER\n    SET\n      ANY_CS,\n      pattern VARCHAR2 CHARACTER\n\
  \    SET\n      srcstr % CHARSET,\n      modifier VARCHAR2 DEFAULT NULL\n  ) return\
  \ BOOLEAN;\npragma FIPSFLAG('REGEXP_LIKE', 1452);\n-- REGEXP_INSTR --\n  function\
  \ REGEXP_INSTR(\n    srcstr VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n      pattern\
  \ VARCHAR2 CHARACTER\n    SET\n      srcstr % CHARSET,\n      position PLS_INTEGER:\
  \ = 1,\n      occurrence PLS_INTEGER: = 1,\n      returnparam PLS_INTEGER: = 0,\n\
  \      modifier VARCHAR2 DEFAULT NULL,\n      subexpression PLS_INTEGER: = 0\n \
  \ ) return PLS_INTEGER;\npragma FIPSFLAG('REGEXP_INSTR', 1452);\nfunction REGEXP_INSTR(\n\
  \    srcstr CLOB CHARACTER\n    SET\n      ANY_CS,\n      pattern VARCHAR2 CHARACTER\n\
  \    SET\n      srcstr % CHARSET,\n      position INTEGER: = 1,\n      occurrence\
  \ INTEGER: = 1,\n      returnparam PLS_INTEGER: = 0,\n      modifier VARCHAR2 DEFAULT\
  \ NULL,\n      subexpression PLS_INTEGER: = 0\n  ) return INTEGER;\npragma FIPSFLAG('REGEXP_INSTR',\
  \ 1452);\n-- REGEXP_SUBSTR --\n  function REGEXP_SUBSTR(\n    srcstr VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      pattern VARCHAR2 CHARACTER\n    SET\n      srcstr\
  \ % CHARSET,\n      position PLS_INTEGER: = 1,\n      occurrence PLS_INTEGER: =\
  \ 1,\n      modifier VARCHAR2 DEFAULT NULL,\n      subexpression PLS_INTEGER: =\
  \ 0\n  ) return VARCHAR2 CHARACTER\nSET\n  srcstr % CHARSET;\npragma FIPSFLAG('REGEXP_SUBSTR',\
  \ 1452);\nfunction REGEXP_SUBSTR(\n    srcstr CLOB CHARACTER\n    SET\n      ANY_CS,\n\
  \      pattern VARCHAR2 CHARACTER\n    SET\n      srcstr % CHARSET,\n      position\
  \ INTEGER: = 1,\n      occurrence INTEGER: = 1,\n      modifier VARCHAR2 DEFAULT\
  \ NULL,\n      subexpression PLS_INTEGER: = 0\n  ) return CLOB CHARACTER\nSET\n\
  \  srcstr % CHARSET;\npragma FIPSFLAG('REGEXP_SUBSTR', 1452);\n-- REGEXP_REPLACE\
  \ --\n  function REGEXP_REPLACE(\n    srcstr VARCHAR2 CHARACTER\n    SET\n     \
  \ ANY_CS,\n      pattern VARCHAR2 CHARACTER\n    SET\n      srcstr % CHARSET,\n\
  \      replacestr VARCHAR2 CHARACTER\n    SET\n      srcstr % CHARSET DEFAULT NULL,\n\
  \      position PLS_INTEGER: = 1,\n      occurrence PLS_INTEGER: = 0,\n      modifier\
  \ VARCHAR2 DEFAULT NULL\n  ) return VARCHAR2 CHARACTER\nSET\n  srcstr % CHARSET;\n\
  pragma FIPSFLAG('REGEXP_REPLACE', 1452);\nfunction REGEXP_REPLACE(\n    srcstr CLOB\
  \ CHARACTER\n    SET\n      ANY_CS,\n      pattern VARCHAR2 CHARACTER\n    SET\n\
  \      srcstr % CHARSET,\n      replacestr CLOB CHARACTER\n    SET\n      srcstr\
  \ % CHARSET DEFAULT NULL,\n      position INTEGER: = 1,\n      occurrence INTEGER:\
  \ = 0,\n      modifier VARCHAR2 DEFAULT NULL\n  ) return CLOB CHARACTER\nSET\n \
  \ srcstr % CHARSET;\npragma FIPSFLAG('REGEXP_REPLACE', 1452);\nfunction REGEXP_REPLACE(\n\
  \    srcstr CLOB CHARACTER\n    SET\n      ANY_CS,\n      pattern VARCHAR2 CHARACTER\n\
  \    SET\n      srcstr % CHARSET,\n      replacestr VARCHAR2 CHARACTER\n    SET\n\
  \      srcstr % CHARSET DEFAULT NULL,\n      position INTEGER: = 1,\n      occurrence\
  \ INTEGER: = 0,\n      modifier VARCHAR2 DEFAULT NULL\n  ) return CLOB CHARACTER\n\
  SET\n  srcstr % CHARSET;\npragma FIPSFLAG('REGEXP_REPLACE', 1452);\n-- End REGEXP\
  \ Support --\n  -- binary_float and binary_double functions and operators.\n  function\
  \ TO_BINARY_FLOAT (RIGHT BINARY_FLOAT) RETURN BINARY_FLOAT;\npragma BUILTIN('TO_BINARY_FLOAT',\
  \ 14, 0, 1);\n-- PEMS_QUICK\n  function TO_BINARY_FLOAT (\n    LEFT VARCHAR2 CHARACTER\n\
  \    SET\n      ANY_CS,\n      FORMAT VARCHAR2 CHARACTER\n    SET\n      LEFT %\
  \ CHARSET\n  ) RETURN BINARY_FLOAT;\nfunction TO_BINARY_FLOAT (\n    LEFT VARCHAR2\
  \ CHARACTER\n    SET\n      ANY_CS,\n      FORMAT VARCHAR2 CHARACTER\n    SET\n\
  \      LEFT % CHARSET,\n      PARMS VARCHAR2 CHARACTER\n    SET\n      LEFT % CHARSET\n\
  \  ) RETURN BINARY_FLOAT;\nfunction TO_BINARY_DOUBLE (RIGHT BINARY_DOUBLE) RETURN\
  \ BINARY_DOUBLE;\npragma BUILTIN('TO_BINARY_DOUBLE', 14, 0, 1);\n-- PEMS_QUICK\n\
  \  function TO_BINARY_DOUBLE (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      FORMAT VARCHAR2 CHARACTER\n    SET\n      LEFT % CHARSET\n  ) RETURN BINARY_DOUBLE;\n\
  function TO_BINARY_DOUBLE (\n    LEFT VARCHAR2 CHARACTER\n    SET\n      ANY_CS,\n\
  \      FORMAT VARCHAR2 CHARACTER\n    SET\n      LEFT % CHARSET,\n      PARMS VARCHAR2\
  \ CHARACTER\n    SET\n      LEFT % CHARSET\n  ) RETURN BINARY_DOUBLE;\nfunction\
  \ 'IS NAN' (N NUMBER) RETURN BOOLEAN;\nfunction 'IS NAN' (F BINARY_FLOAT) RETURN\
  \ BOOLEAN;\nfunction 'IS NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;\nfunction 'IS INFINITE'\
  \ (N NUMBER) RETURN BOOLEAN;\nfunction 'IS INFINITE' (F BINARY_FLOAT) RETURN BOOLEAN;\n\
  function 'IS INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;\nfunction 'IS NOT NAN'\
  \ (N NUMBER) RETURN BOOLEAN;\nfunction 'IS NOT NAN' (F BINARY_FLOAT) RETURN BOOLEAN;\n\
  function 'IS NOT NAN' (D BINARY_DOUBLE) RETURN BOOLEAN;\nfunction 'IS NOT INFINITE'\
  \ (N NUMBER) RETURN BOOLEAN;\nfunction 'IS NOT INFINITE' (F BINARY_FLOAT) RETURN\
  \ BOOLEAN;\nfunction 'IS NOT INFINITE' (D BINARY_DOUBLE) RETURN BOOLEAN;\nfunction\
  \ TO_CHAR (left binary_float, format varchar2) return VARCHAR2;\nfunction TO_CHAR\
  \ (left binary_double, format varchar2) return VARCHAR2;\nfunction TO_CHAR(\n  \
  \  left binary_float,\n    format varchar2,\n    parms varchar2\n  ) return varchar2;\n\
  function TO_CHAR(\n    left binary_double,\n    format varchar2,\n    parms varchar2\n\
  \  ) return varchar2;\nfunction TO_NCHAR(left binary_float, format nvarchar2) return\
  \ NVARCHAR2;\nfunction TO_NCHAR(left binary_double, format nvarchar2) return NVARCHAR2;\n\
  function TO_NCHAR(\n    left binary_float,\n    format nvarchar2,\n    parms nvarchar2\n\
  \  ) return nvarchar2;\nfunction TO_NCHAR(\n    left binary_double,\n    format\
  \ nvarchar2,\n    parms nvarchar2\n  ) return nvarchar2;\nfunction 'REMAINDER'(n1\
  \ NUMBER, n2 NUMBER) return NUMBER;\npragma FIPSFLAG('REMAINDER', 1452);\nfunction\
  \ REMAINDER(n1 NUMBER, n2 NUMBER) return NUMBER;\npragma FIPSFLAG(REMAINDER, 1452);\n\
  function 'REMAINDER'(f1 BINARY_FLOAT, f2 BINARY_FLOAT) return BINARY_FLOAT;\npragma\
  \ FIPSFLAG('REMAINDER', 1452);\nfunction REMAINDER(f1 BINARY_FLOAT, f2 BINARY_FLOAT)\
  \ return BINARY_FLOAT;\npragma FIPSFLAG(REMAINDER, 1452);\nfunction 'REMAINDER'(d1\
  \ BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;\npragma FIPSFLAG('REMAINDER',\
  \ 1452);\nfunction REMAINDER(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE) return BINARY_DOUBLE;\n\
  pragma FIPSFLAG(REMAINDER, 1452);\nfunction '=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT)\
  \ return BOOLEAN;\npragma BUILTIN('=', 2, 2, 15);\nfunction '!=' (LEFT BINARY_FLOAT,\
  \ RIGHT BINARY_FLOAT) return BOOLEAN;\npragma BUILTIN('!=', 5, 2, 16);\npragma FIPSFLAG('!=',\
  \ 1452);\nfunction '<' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;\n\
  pragma BUILTIN('<', 4, 2, 17);\nfunction '<=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT)\
  \ return BOOLEAN;\npragma BUILTIN('<=', 6, 2, 18);\nfunction '>' (LEFT BINARY_FLOAT,\
  \ RIGHT BINARY_FLOAT) return BOOLEAN;\npragma BUILTIN('>', 1, 2, 19);\nfunction\
  \ '>=' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BOOLEAN;\npragma BUILTIN('>=',\
  \ 3, 2, 20);\nfunction 'IS NULL' (n BINARY_FLOAT) return BOOLEAN;\npragma BUILTIN('IS\
  \ NULL', 0, 2, 0);\nfunction 'IS NOT NULL' (n BINARY_FLOAT) return BOOLEAN;\npragma\
  \ BUILTIN('IS NOT NULL', 0, 2, 50);\nfunction NVL(f1 BINARY_FLOAT, f2 BINARY_FLOAT)\
  \ return BINARY_FLOAT;\npragma FIPSFLAG('NVL', 1452);\nfunction '+' (RIGHT BINARY_FLOAT)\
  \ return BINARY_FLOAT;\npragma BUILTIN('+', 14, 0, 1);\nfunction '-' (RIGHT BINARY_FLOAT)\
  \ return BINARY_FLOAT;\npragma BUILTIN('-', 15, 2, 23);\nfunction ABS(F BINARY_FLOAT)\
  \ return BINARY_FLOAT;\npragma FIPSFLAG('ABS', 1452);\nfunction '+' (LEFT BINARY_FLOAT,\
  \ RIGHT BINARY_FLOAT) return BINARY_FLOAT;\npragma BUILTIN('+', 14, 2, 24);\nfunction\
  \ '-' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;\npragma BUILTIN('-',\
  \ 15, 2, 25);\nfunction '*' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT) return BINARY_FLOAT;\n\
  pragma BUILTIN('*', 17, 2, 26);\nfunction '/' (LEFT BINARY_FLOAT, RIGHT BINARY_FLOAT)\
  \ return BINARY_FLOAT;\npragma BUILTIN('/', 18, 2, 27);\nfunction 'REM' (LEFT BINARY_FLOAT,\
  \ RIGHT BINARY_FLOAT) return BINARY_FLOAT;\npragma FIPSFLAG('REM', 1452);\nfunction\
  \ 'MOD'(F1 BINARY_FLOAT, F2 BINARY_FLOAT) return BINARY_FLOAT;\npragma FIPSFLAG('MOD',\
  \ 1452);\nfunction FLOOR(F BINARY_FLOAT) return BINARY_FLOAT;\npragma FIPSFLAG('FLOOR',\
  \ 1452);\nfunction CEIL(F BINARY_FLOAT) return BINARY_FLOAT;\npragma FIPSFLAG('CEIL',\
  \ 1452);\nfunction SIGN(f BINARY_FLOAT) return SIGNTYPE;\npragma FIPSFLAG('SIGN',\
  \ 1452);\nfunction SQRT(f BINARY_FLOAT) return BINARY_FLOAT;\npragma FIPSFLAG('SQRT',\
  \ 1452);\nfunction TRUNC (F BINARY_FLOAT) return BINARY_FLOAT;\npragma FIPSFLAG('TRUNC',\
  \ 1452);\nfunction ROUND (LEFT BINARY_FLOAT) return BINARY_FLOAT;\npragma FIPSFLAG('ROUND',\
  \ 1452);\nfunction '=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;\n\
  pragma BUILTIN('=', 2, 2, 28);\nfunction '!=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)\
  \ return BOOLEAN;\n-- also <> and ~=\n  pragma BUILTIN('!=', 5, 2, 29);\npragma\
  \ FIPSFLAG('!=', 1452);\nfunction '<' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)\
  \ return BOOLEAN;\npragma BUILTIN('<', 4, 2, 30);\nfunction '<=' (LEFT BINARY_DOUBLE,\
  \ RIGHT BINARY_DOUBLE) return BOOLEAN;\npragma BUILTIN('<=', 6, 2, 31);\nfunction\
  \ '>' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;\npragma BUILTIN('>',\
  \ 1, 2, 32);\nfunction '>=' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BOOLEAN;\n\
  pragma BUILTIN('>=', 3, 2, 33);\nfunction 'IS NULL' (n BINARY_DOUBLE) return BOOLEAN;\n\
  pragma BUILTIN('IS NULL', 0, 2, 0);\nfunction 'IS NOT NULL' (n BINARY_DOUBLE) return\
  \ BOOLEAN;\npragma BUILTIN('IS NOT NULL', 0, 2, 50);\nfunction NVL(d1 BINARY_DOUBLE,\
  \ d2 BINARY_DOUBLE) return BINARY_DOUBLE;\npragma FIPSFLAG('NVL', 1452);\nfunction\
  \ '+' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;\npragma BUILTIN('+', 14, 0, 1);\n\
  function '-' (RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;\npragma BUILTIN('-', 15,\
  \ 2, 36);\nfunction ABS(D BINARY_DOUBLE) return BINARY_DOUBLE;\npragma FIPSFLAG('ABS',\
  \ 1452);\nfunction ACOS(D BINARY_DOUBLE) return BINARY_DOUBLE;\npragma FIPSFLAG('ACOS',\
  \ 1452);\nfunction ASIN(D BINARY_DOUBLE) return BINARY_DOUBLE;\npragma FIPSFLAG('ASIN',\
  \ 1452);\nfunction ATAN(D BINARY_DOUBLE) return BINARY_DOUBLE;\npragma FIPSFLAG('ATAN',\
  \ 1452);\nfunction ATAN2(x BINARY_DOUBLE, y BINARY_DOUBLE) return BINARY_DOUBLE;\n\
  pragma FIPSFLAG('ATAN2', 1452);\nfunction '+' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)\
  \ return BINARY_DOUBLE;\npragma BUILTIN('+', 14, 2, 37);\nfunction '-' (LEFT BINARY_DOUBLE,\
  \ RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;\npragma BUILTIN('-', 15, 2, 38);\n\
  function '*' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;\npragma\
  \ BUILTIN('*', 17, 2, 39);\nfunction '/' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE)\
  \ return BINARY_DOUBLE;\npragma BUILTIN('/', 18, 2, 40);\nfunction 'REM' (LEFT BINARY_DOUBLE,\
  \ RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;\npragma FIPSFLAG('REM', 1452);\nfunction\
  \ 'MOD'(D1 BINARY_DOUBLE, D2 BINARY_DOUBLE) return BINARY_DOUBLE;\npragma FIPSFLAG('MOD',\
  \ 1452);\nfunction '**' (LEFT BINARY_DOUBLE, RIGHT BINARY_DOUBLE) return BINARY_DOUBLE;\n\
  pragma FIPSFLAG('**', 1452);\nfunction FLOOR(D BINARY_DOUBLE) return BINARY_DOUBLE;\n\
  pragma FIPSFLAG('FLOOR', 1452);\nfunction CEIL(D BINARY_DOUBLE) return BINARY_DOUBLE;\n\
  pragma FIPSFLAG('CEIL', 1452);\nfunction SQRT(d BINARY_DOUBLE) return BINARY_DOUBLE;\n\
  pragma FIPSFLAG('SQRT', 1452);\nfunction SIGN(d BINARY_DOUBLE) return SIGNTYPE;\n\
  pragma FIPSFLAG('SIGN', 1452);\nfunction COS(D BINARY_DOUBLE) return BINARY_DOUBLE;\n\
  function SIN(D BINARY_DOUBLE) return BINARY_DOUBLE;\nfunction TAN(D BINARY_DOUBLE)\
  \ return BINARY_DOUBLE;\nfunction COSH(D BINARY_DOUBLE) return BINARY_DOUBLE;\n\
  function SINH(D BINARY_DOUBLE) return BINARY_DOUBLE;\nfunction TANH(D BINARY_DOUBLE)\
  \ return BINARY_DOUBLE;\nfunction EXP(D BINARY_DOUBLE) return BINARY_DOUBLE;\nfunction\
  \ LN(D BINARY_DOUBLE) return BINARY_DOUBLE;\nfunction LOG (LEFT BINARY_DOUBLE, RIGHT\
  \ BINARY_DOUBLE) return BINARY_DOUBLE;\nfunction TRUNC (D BINARY_DOUBLE) return\
  \ BINARY_DOUBLE;\npragma FIPSFLAG('TRUNC', 1452);\nfunction ROUND (LEFT BINARY_DOUBLE)\
  \ return BINARY_DOUBLE;\npragma FIPSFLAG('ROUND', 1452);\nfunction POWER (d BINARY_DOUBLE,\
  \ e BINARY_DOUBLE) return BINARY_DOUBLE;\npragma FIPSFLAG('POWER', 1452);\nfunction\
  \ NANVL(n1 NUMBER, n2 NUMBER) return NUMBER;\nfunction NANVL(f1 BINARY_FLOAT, f2\
  \ BINARY_FLOAT) return BINARY_FLOAT;\nfunction NANVL(d1 BINARY_DOUBLE, d2 BINARY_DOUBLE)\
  \ return BINARY_DOUBLE;\nfunction GREATEST (pattern BINARY_FLOAT) return BINARY_FLOAT;\n\
  pragma BUILTIN('GREATEST', 12, 240, 240);\n-- This is special cased in PH2\n  function\
  \ GREATEST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;\npragma BUILTIN('GREATEST',\
  \ 12, 240, 240);\n-- This is special cased in PH2\n  function LEAST (pattern BINARY_FLOAT)\
  \ return BINARY_FLOAT;\npragma BUILTIN('LEAST', 13, 240, 240);\n-- This is special\
  \ cased in PH2\n  function LEAST (pattern BINARY_DOUBLE) return BINARY_DOUBLE;\n\
  pragma BUILTIN('LEAST', 13, 240, 240);\n-- This is special cased in PH2\n  function\
  \ '+' (RIGHT PLS_INTEGER) return PLS_INTEGER;\npragma BUILTIN('+', 14, 0, 1);\n\
  -- PEMS_QUICK\n  function '-' (RIGHT PLS_INTEGER) return PLS_INTEGER;\npragma BUILTIN('-',\
  \ 15, 2, 41);\nfunction ABS(I PLS_INTEGER) return PLS_INTEGER;\npragma FIPSFLAG('ABS',\
  \ 1452);\nfunction '+' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return PLS_INTEGER;\n\
  pragma BUILTIN('+', 14, 2, 42);\nfunction '-' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER)\
  \ return PLS_INTEGER;\npragma BUILTIN('-', 14, 2, 43);\nfunction '*' (LEFT PLS_INTEGER,\
  \ RIGHT PLS_INTEGER) return PLS_INTEGER;\npragma BUILTIN('*', 14, 2, 44);\nfunction\
  \ '=' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;\npragma BUILTIN('=',\
  \ 2, 2, 45);\n-- PEMS_PLS_INTEGER, PEMDCMEQ\n  function '!=' (LEFT PLS_INTEGER,\
  \ RIGHT PLS_INTEGER) return BOOLEAN;\n-- also <> and ~=\n  pragma BUILTIN('!=',\
  \ 5, 2, 46);\n-- PEMS_PLS_INTEGER, PEMDCMNE\n  pragma FIPSFLAG('!=', 1452);\nfunction\
  \ '<' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;\npragma BUILTIN('<',\
  \ 4, 2, 47);\n-- PEMS_PLS_INTEGER, PEMDCMLT\n  function '<=' (LEFT PLS_INTEGER,\
  \ RIGHT PLS_INTEGER) return BOOLEAN;\npragma BUILTIN('<=', 6, 2, 48);\n-- PEMS_PLS_INTEGER,\
  \ PEMDCMLE\n  function '>' (LEFT PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;\n\
  pragma BUILTIN('>', 1, 2, 49);\n-- PEMS_PLS_INTEGER, PEMDCMGT\n  function '>=' (LEFT\
  \ PLS_INTEGER, RIGHT PLS_INTEGER) return BOOLEAN;\npragma BUILTIN('>=', 3, 2, 51);\n\
  -- PEMS_PLS_INTEGER, PEMDCMGE\n  function 'IS NULL' (I PLS_INTEGER) return BOOLEAN;\n\
  pragma BUILTIN('IS NULL', 0, 2, 0);\n-- PEMS_PLS_INTEGER, PEMDNUL\n  function 'IS\
  \ NOT NULL' (I PLS_INTEGER) return BOOLEAN;\npragma BUILTIN('IS NOT NULL', 0, 2,\
  \ 50);\n-- PEMS_PLS_INTEGER, PEMDNUL\n  function NVL(I1 PLS_INTEGER, I2 PLS_INTEGER)\
  \ return PLS_INTEGER;\npragma FIPSFLAG('NVL', 1452);\nfunction TRUNC (i pls_integer,\
  \ places pls_integer: = 0) return pls_integer;\npragma FIPSFLAG('TRUNC', 1452);\n\
  function ROUND (i pls_integer, places pls_integer: = 0) return pls_integer;\npragma\
  \ FIPSFLAG('ROUND', 1452);\nfunction SIGN(i PLS_INTEGER) return SIGNTYPE;\npragma\
  \ FIPSFLAG('SIGN', 1452);\nfunction GREATEST (pattern PLS_INTEGER) return PLS_INTEGER;\n\
  pragma BUILTIN('GREATEST', 12, 240, 240);\n-- This is special cased in PH2\n  function\
  \ LEAST (pattern PLS_INTEGER) return PLS_INTEGER;\npragma BUILTIN('LEAST', 13, 240,\
  \ 240);\n-- This is special cased in PH2\n  -- MultiSet Functions and Operators.\n\
  \  -- Equality\n  function '='(\n    collection1 IN \"<TABLE_1>\",\n    collection2\
  \ IN \"<TABLE_1>\"\n  ) return BOOLEAN;\npragma BUILTIN('=', 2, 16, 1);\nfunction\
  \ '!='(\n    collection1 IN \"<TABLE_1>\",\n    collection2 IN \"<TABLE_1>\"\n \
  \ ) return BOOLEAN;\npragma BUILTIN('!=', 2, 16, 2);\nfunction CARDINALITY (collection\
  \ IN \"<TABLE_1>\") return PLS_INTEGER;\nfunction\nSET\n  (collection IN \"<TABLE_1>\"\
  ) return \"<TABLE_1>\";\npragma BUILTIN('SET', 18, 2, 40);\n-- Dummy\n  function\
  \ 'IS A SET' (collection IN \"<TABLE_1>\") return BOOLEAN;\npragma BUILTIN('IS A\
  \ SET', 18, 2, 40);\n-- Dummy\n  function 'IS NOT A SET'(collection IN \"<TABLE_1>\"\
  ) return BOOLEAN;\npragma BUILTIN('IS NOT A SET', 18, 2, 40);\n-- Dummy\n  function\
  \ 'IS EMPTY' (collection IN \"<TABLE_1>\") return BOOLEAN;\nfunction 'IS NOT EMPTY'(collection\
  \ IN \"<TABLE_1>\") return BOOLEAN;\n-- IS A SUBMULTISET OF\n  function 'SUBMULTISET'\
  \ (\n    collection IN \"<TABLE_1>\",\n    collection2 IN \"<TABLE_1>\"\n  ) return\
  \ BOOLEAN;\npragma BUILTIN('SUBMULTISET', 18, 2, 40);\nfunction 'MULTISET_UNION_ALL'\
  \ (\n    collection IN \"<TABLE_1>\",\n    collection2 IN \"<TABLE_1>\"\n  ) return\
  \ \"<TABLE_1>\";\npragma BUILTIN('MULTISET_UNION_ALL', 18, 2, 40);\nfunction 'MULTISET_UNION_DISTINCT'\
  \ (\n    collection IN \"<TABLE_1>\",\n    collection2 IN \"<TABLE_1>\"\n  ) return\
  \ \"<TABLE_1>\";\npragma BUILTIN('MULTISET_UNION_DISTINCT', 18, 2, 40);\n-- Dummy\n\
  \  function 'MULTISET_EXCEPT_ALL' (\n    collection IN \"<TABLE_1>\",\n    collection2\
  \ IN \"<TABLE_1>\"\n  ) return \"<TABLE_1>\";\npragma BUILTIN('MULTISET_EXCEPT_ALL',\
  \ 18, 2, 40);\n-- Dummy\n  function 'MULTISET_EXCEPT_DISTINCT' (\n    collection\
  \ IN \"<TABLE_1>\",\n    collection2 IN \"<TABLE_1>\"\n  ) return \"<TABLE_1>\"\
  ;\npragma BUILTIN('MULTISET_EXCEPT_DISTINCT', 18, 2, 40);\n-- Dummy\n  function\
  \ 'MULTISET_INTERSECT_ALL' (\n    collection IN \"<TABLE_1>\",\n    collection2\
  \ IN \"<TABLE_1>\"\n  ) return \"<TABLE_1>\";\npragma BUILTIN('MULTISET_INTERSECT_ALL',\
  \ 18, 2, 40);\n-- Dummy\n  function 'MULTISET_INTERSECT_DISTINCT' (\n    collection\
  \ IN \"<TABLE_1>\",\n    collection2 IN \"<TABLE_1>\"\n  ) return \"<TABLE_1>\"\
  ;\npragma BUILTIN('MULTISET_INTERSECT_DISTINCT', 18, 2, 40);\n-- Dummy\n  -- These\
  \ are dummy procedures for correct management of new control\n  -- statements added\
  \ to PL/SQL. They ensure local procedures which have the\n  -- same names as newly\
  \ introduced keywords are not masked by those keywords.\n  procedure continue;\n\
  -- REGEXP_COUNT --\n  function REGEXP_COUNT(\n    srcstr VARCHAR2 CHARACTER\n  \
  \  SET\n      ANY_CS,\n      pattern VARCHAR2 CHARACTER\n    SET\n      srcstr %\
  \ CHARSET,\n      position PLS_INTEGER: = 1,\n      modifier VARCHAR2 DEFAULT NULL\n\
  \  ) return PLS_INTEGER;\npragma FIPSFLAG('REGEXP_COUNT', 1452);\nfunction REGEXP_COUNT(\n\
  \    srcstr CLOB CHARACTER\n    SET\n      ANY_CS,\n      pattern VARCHAR2 CHARACTER\n\
  \    SET\n      srcstr % CHARSET,\n      position INTEGER: = 1,\n      modifier\
  \ VARCHAR2 DEFAULT NULL\n  ) return INTEGER;\npragma FIPSFLAG('REGEXP_COUNT', 1452);\n\
  --#### All user-visible declarations should preceed this point.  The\n  --#### following\
  \ are implementation-oriented pragmas that may need\n  --#### editing in the future;\
  \ we would prefer to be able to edit them\n  --#### without affecting the rft numbering\
  \ of user-visible items.\n  --#### interface pragmas\n  --#### Note that for any\
  \ ICD which maps directly to a PVM\n  --#### Opcode MUST be mapped to pes_dummy.\n\
  \  --#### An ICD which invokes another ICD by flipping operands is\n  --#### mapped\
  \ to pes_flip, and an ICD whose result is the inverse of\n  --#### another ICD is\
  \ mapped to pes_invert\n  --#### New ICDs should be placed at the end of this list,\
  \ and a\n  --#### corresponding entry must be made in the ICD table in pdz7\n  PRAGMA\
  \ interface(c, length, \"pes_dummy\", 1);\nPRAGMA interface(c, substr, \"pes_dummy\"\
  , 1);\nPRAGMA interface(c, instr, \"pesist\", 1);\nPRAGMA interface(c, UPPER, \"\
  pesupp\", 1);\nPRAGMA interface(c, LOWER, \"peslow\", 1);\nPRAGMA interface(c, ASCII,\
  \ \"pesasc\");\nPRAGMA interface(c, ASCIISTR, \"pesastr\");\nPRAGMA interface(c,\
  \ UNISTR, \"pesustr\");\nPRAGMA interface(c, CHR, \"peschr\");\nPRAGMA interface(c,\
  \ \" SYS$STANDARD_CHR\", \"peschr\");\nPRAGMA interface(c, INITCAP, \"pesicp\");\n\
  PRAGMA interface(c, LPAD, \"peslpd\", 1);\nPRAGMA interface(c, LPAD, \"peslpd\"\
  , 2);\nPRAGMA interface(c, RPAD, \"pesrpd\", 1);\nPRAGMA interface(c, RPAD, \"pesrpd\"\
  , 2);\nPRAGMA interface(c, REPLACE, \"pesrep\", 1);\nPRAGMA interface(c, LTRIM,\
  \ \"pesltr\", 1);\nPRAGMA interface(c, LTRIM, \"pesltr\", 2);\nPRAGMA interface(c,\
  \ RTRIM, \"pesrtr\", 1);\nPRAGMA interface(c, RTRIM, \"pesrtr\", 2);\nPRAGMA interface(c,\
  \ 'LIKE', \"peslik\", 1);\nPRAGMA interface(c, 'LIKE', \"pesli2\", 2);\nPRAGMA interface(c,\
  \ ABS, \"pes_dummy\", 1);\nPRAGMA interface(c, 'MOD', \"pesmod\", 1);\nPRAGMA interface(c,\
  \ floor, \"pesflo\", 1);\nPRAGMA interface(c, CEIL, \"pescei\", 1);\nPRAGMA interface\
  \ (c, SQRT, \"pessqt\", 1);\nPRAGMA interface(c, SIGN, \"pessgn\", 1);\nPRAGMA interface(c,\
  \ cos, \"pescos\", 1);\nPRAGMA interface(c, sin, \"pessin\", 1);\nPRAGMA interface(c,\
  \ TAN, \"pestan\", 1);\nPRAGMA interface(c, COSH, \"pescsh\", 1);\nPRAGMA interface(c,\
  \ SINH, \"pessnh\", 1);\nPRAGMA interface(c, TANH, \"pestnh\", 1);\nPRAGMA interface(c,\
  \ EXP, \"pesexp\", 1);\nPRAGMA interface(c, LN, \"pesln\", 1);\nPRAGMA interface(c,\
  \ BITAND, \"pesbtd\", 1);\nPRAGMA interface(c, BITAND, \"pesbtdn\", 2);\nPRAGMA\
  \ interface(c, LOG, \"peslog\", 1);\nPRAGMA interface(c, TRUNC, \"pestru\", 1);\n\
  PRAGMA interface(c, ROUND, \"pesrnd\", 1);\nPRAGMA interface(c, POWER, \"pespow\"\
  , 1);\nPRAGMA interface(c, NEW_TIME, \"pesnwt\");\nPRAGMA interface(c, TO_DATE,\
  \ \"pesc2d\", 4);\nPRAGMA interface(c, TO_NUMBER, \"pesc2n\", 3);\nPRAGMA interface(c,\
  \ TO_NUMBER, \"pesc2n\", 4);\nPRAGMA interface(c, '>=', \"pes_flip\", 5);\nPRAGMA\
  \ interface(c, '>', \"pes_flip\", 5);\nPRAGMA interface(c, '<=', \"peszle\", 5);\n\
  PRAGMA interface(c, '<', \"peszlt\", 5);\n-- ICD #50\n  PRAGMA interface(c, '=',\
  \ \"peszeq\", 5);\nPRAGMA interface(c, '!=', \"pes_invert\", 5);\nPRAGMA interface(c,\
  \ nlssort, \"pesxco\", 2);\nPRAGMA interface(c, NLS_UPPER, \"pesxup\", 1);\nPRAGMA\
  \ interface(c, NLS_UPPER, \"peslcnup\", 3);\n-- LOB NLS_UPPER\n  PRAGMA interface(c,\
  \ NLS_UPPER, \"peslcnup\", 4);\n-- LOB NLS_UPPER\n  PRAGMA interface(c, NLS_LOWER,\
  \ \"pesxlo\", 1);\nPRAGMA interface(c, NLS_LOWER, \"peslcnlr\", 3);\n-- LOB NLS_LOWER\n\
  \  PRAGMA interface(c, NLS_LOWER, \"peslcnlr\", 4);\n-- LOB NLS_LOWER\n  PRAGMA\
  \ interface(c, NLS_INITCAP, \"pesxcp\", 1);\nPRAGMA interface(c, lengthb, \"pes_dummy\"\
  , 1);\nPRAGMA interface(c, substrb, \"pes_dummy\", 1);\nPRAGMA interface(c, instrb,\
  \ \"pesxis\", 1);\nPRAGMA interface(c, TO_SINGLE_BYTE, \"pesxsi\");\nPRAGMA interface(c,\
  \ TO_MULTI_BYTE, \"pesxmu\");\nPRAGMA interface(c, TO_CHAR, \"pesd2c\", 5);\nPRAGMA\
  \ interface(c, TO_CHAR, \"pesn2c\", 6);\nPRAGMA interface(c, TO_NCHAR, \"pesd2c\"\
  , 4);\nPRAGMA interface(c, TO_NCHAR, \"pesn2c\", 5);\nPRAGMA interface(c, \" SYS$STANDARD_TRANSLATE\"\
  , \"pesxcs\");\nPRAGMA interface(c, ATAN, \"pesatan\", 1);\nPRAGMA interface(c,\
  \ EMPTY_CLOB, \"peslcem\");\nPRAGMA interface(c, EMPTY_BLOB, \"peslbem\");\nPRAGMA\
  \ interface(c, BFILENAME, \"pesfnm\");\nPRAGMA interface(c, TO_TIME, \"pes3tm\"\
  , 2);\nPRAGMA interface(c, TO_TIME, \"pes3tm\", 3);\nPRAGMA interface(c, TO_TIMESTAMP,\
  \ \"pes3ts\", 2);\nPRAGMA interface(c, TO_TIMESTAMP, \"pes3ts\", 3);\nPRAGMA interface(c,\
  \ TO_TIMESTAMP_TZ, \"pes3tp\", 2);\nPRAGMA interface(c, TO_TIMESTAMP_TZ, \"pes3tp\"\
  , 3);\nPRAGMA interface(c, TO_TIME_TZ, \"pes3te\", 2);\nPRAGMA interface(c, TO_TIME_TZ,\
  \ \"pes3te\", 3);\nPRAGMA interface(c, TO_DSINTERVAL, \"pes2dsi\", 2);\nPRAGMA interface(c,\
  \ SYS_AT_TIME_ZONE, \"pesatz\", 1);\nPRAGMA interface(c, SYS_AT_TIME_ZONE, \"pesatz\"\
  , 2);\nPRAGMA interface(c, SESSIONTIMEZONE, \"pesstz\", 1);\nPRAGMA interface(c,\
  \ \" SYS$STANDARD_TRIM\", \"pestrim\", 1);\nPRAGMA interface(c, \" SYS$STANDARD_TRIM\"\
  , \"pestrim\", 2);\nPRAGMA interface(c, \" SYS$STANDARD_TRIM\", \"pestrim\", 3);\n\
  PRAGMA interface(c, TRIM, \"pestrim\", 1);\n-- Datetime addition\n  PRAGMA interface(c,\
  \ '+', \"pesati\", 5);\n--  +(tsp, iym) return tsp\n  PRAGMA interface(c, '+', \"\
  pesati\", 6);\n--  +(tsp, ids) return tsp\n  PRAGMA interface(c, '+', \"pesati\"\
  , 7);\n--  +(tsz, iym) return tsz\n  PRAGMA interface(c, '+', \"pesati\", 8);\n\
  --  +(tsz, ids) return tsz\n  PRAGMA interface(c, '+', \"pesati\", 9);\n--  +(tim,\
  \ ids) return tim\n  PRAGMA interface(c, '+', \"pesati\", 10);\n--  +(tmz, ids)\
  \ return tmz\n  PRAGMA interface(c, '+', \"pesadi\", 11);\n--  +(dat, iym) return\
  \ dat\n  PRAGMA interface(c, '+', \"pesadi\", 12);\n--  +(dat, ids) return dat\n\
  \  PRAGMA interface(c, '+', \"pes_flip\", 13);\n--  +(iym, tsp) return tsp\n  PRAGMA\
  \ interface(c, '+', \"pes_flip\", 14);\n--  +(iym, tsz) return tsz -- ICD #100\n\
  \  PRAGMA interface(c, '+', \"pes_flip\", 15);\n--  +(iym, dat) return dat\n  PRAGMA\
  \ interface(c, '+', \"pes_flip\", 16);\n--  +(ids, tsp) return tsp\n  PRAGMA interface(c,\
  \ '+', \"pes_flip\", 17);\n--  +(ids, tsz) return tsz\n  PRAGMA interface(c, '+',\
  \ \"pes_flip\", 18);\n--  +(ids, tim) return tim\n  PRAGMA interface(c, '+', \"\
  pes_flip\", 19);\n--  +(ids, tmz) return tmz\n  PRAGMA interface(c, '+', \"pes_flip\"\
  , 20);\n--  +(ids, dat) return dat\n  PRAGMA interface(c, '+', \"pesaii\", 21);\n\
  --  +(ids, ids) return ids\n  PRAGMA interface(c, '+', \"pesaii\", 22);\n--  +(iym,\
  \ iym) return iym\n  PRAGMA interface(c, '+', \"pesati\", 23);\n--  +(ltz, iym)\
  \ return ltz\n  PRAGMA interface(c, '+', \"pesati\", 24);\n--  +(ltz, ids) return\
  \ ltz\n  PRAGMA interface(c, '+', \"pes_flip\", 25);\n--  +(iym, ltz) return ltz\n\
  \  PRAGMA interface(c, '+', \"pes_flip\", 26);\n--  +(ids, ltz) return ltz\n  --\
  \ Datetime subtraction\n  PRAGMA interface(c, '-', \"pessti\", 6);\n--  -(tsp, iym)\
  \ return tsp\n  PRAGMA interface(c, '-', \"pessti\", 7);\n--  -(tsp, ids) return\
  \ tsp\n  PRAGMA interface(c, '-', \"pessti\", 8);\n--  -(tsz, iym) return tsz\n\
  \  PRAGMA interface(c, '-', \"pessti\", 9);\n--  -(tsz, ids) return tsz\n  PRAGMA\
  \ interface(c, '-', \"pessti\", 10);\n--  -(tim, ids) return tim\n  PRAGMA interface(c,\
  \ '-', \"pessti\", 11);\n--  -(tmz, ids) return tmz\n  PRAGMA interface(c, '-',\
  \ \"pessdi\", 12);\n--  -(dat, iym) return dat\n  PRAGMA interface(c, '-', \"pessdi\"\
  , 13);\n--  -(dat, ids) return dat\n  PRAGMA interface(c, '-', \"pessii\", 14);\n\
  --  -(iym, iym) return iym\n  PRAGMA interface(c, '-', \"pessii\", 15);\n--  -(ids,\
  \ ids) return ids\n  PRAGMA interface(c, '-', \"pessttds\", 16);\n--  -(tim, tim)\
  \ return ids\n  PRAGMA interface(c, '-', \"pessttds\", 17);\n--  -(tsp, tsp) return\
  \ ids\n  PRAGMA interface(c, '-', \"pessttds\", 18);\n--  -(tmz, tmz) return ids\n\
  \  PRAGMA interface(c, '-', \"pessttds\", 19);\n--  -(tsz, tsz) return ids\n  PRAGMA\
  \ interface(c, '-', \"pessti\", 20);\n--  -(ltz, iym) return iym\n  PRAGMA interface(c,\
  \ '-', \"pessti\", 21);\n--  -(ltz, ids) return ids\n  PRAGMA interface(c, '-',\
  \ \"pessttds\", 22);\n--  -(ltz, ltz) return ids\n  PRAGMA interface(c, \" SYS$DSINTERVALSUBTRACT\"\
  , \"pessttds\", 1);\nPRAGMA interface(c, \" SYS$DSINTERVALSUBTRACT\", \"pessttds\"\
  , 2);\nPRAGMA interface(c, \" SYS$DSINTERVALSUBTRACT\", \"pessttds\", 3);\nPRAGMA\
  \ interface(c, \" SYS$DSINTERVALSUBTRACT\", \"pessttds\", 4);\nPRAGMA interface(c,\
  \ \" SYS$DSINTERVALSUBTRACT\", \"pessddds\", 5);\nPRAGMA interface(c, \" SYS$DSINTERVALSUBTRACT\"\
  , \"pessttds\", 6);\nPRAGMA interface(c, \" SYS$YMINTERVALSUBTRACT\", \"pessttym\"\
  , 1);\nPRAGMA interface(c, \" SYS$YMINTERVALSUBTRACT\", \"pessttym\", 2);\nPRAGMA\
  \ interface(c, \" SYS$YMINTERVALSUBTRACT\", \"pessddym\", 3);\nPRAGMA interface(c,\
  \ \" SYS$YMINTERVALSUBTRACT\", \"pessttym\", 4);\n-- Datetime multiplication\n \
  \ PRAGMA interface(c, '*', \"pesmni\", 2);\n--  *(num, iym) return iym\n  PRAGMA\
  \ interface(c, '*', \"pesmni\", 3);\n--  *(num, ids) return ids\n  PRAGMA interface(c,\
  \ '*', \"pes_flip\", 4);\n--  *(iym, num) return iym\n  PRAGMA interface(c, '*',\
  \ \"pes_flip\", 5);\n--  *(ids, num) return ids\n  -- Datetime division\n  PRAGMA\
  \ interface(c, '/', \"pesdvin\", 2);\n--  /(iym, num) return iym\n  PRAGMA interface(c,\
  \ '/', \"pesdvin\", 3);\n--  /(ids, num) return ids\n  -- TIME\n  PRAGMA interface(c,\
  \ '=', \"pes_dummy\", 9);\nPRAGMA interface(c, '!=', \"pes_invert\", 9);\nPRAGMA\
  \ interface(c, '>', \"pes_flip\", 8);\nPRAGMA interface(c, '<', \"pes_dummy\", 8);\n\
  PRAGMA interface(c, '>=', \"pes_flip\", 8);\n-- ICD #150\n  PRAGMA interface(c,\
  \ '<=', \"pes_dummy\", 8);\n-- TIME WITH TIME ZONE\n  PRAGMA interface(c, '=', \"\
  pes_dummy\", 10);\nPRAGMA interface(c, '!=', \"pes_invert\", 10);\nPRAGMA interface(c,\
  \ '>', \"pes_flip\", 9);\nPRAGMA interface(c, '<', \"pes_dummy\", 9);\nPRAGMA interface(c,\
  \ '>=', \"pes_flip\", 9);\nPRAGMA interface(c, '<=', \"pes_dummy\", 9);\n-- TIMESTAMP\n\
  \  PRAGMA interface(c, '=', \"pes_dummy\", 11);\nPRAGMA interface(c, '!=', \"pes_invert\"\
  , 11);\nPRAGMA interface(c, '>', \"pes_flip\", 10);\nPRAGMA interface(c, '<', \"\
  pes_dummy\", 10);\nPRAGMA interface(c, '>=', \"pes_flip\", 10);\nPRAGMA interface(c,\
  \ '<=', \"pes_dummy\", 10);\n-- INTERVAL YEAR TO MONTH\n  PRAGMA interface(c, '=',\
  \ \"pes_dummy\", 12);\nPRAGMA interface(c, '!=', \"pes_invert\", 12);\nPRAGMA interface(c,\
  \ '>', \"pes_flip\", 11);\nPRAGMA interface(c, '<', \"pes_dummy\", 11);\nPRAGMA\
  \ interface(c, '>=', \"pes_flip\", 11);\nPRAGMA interface(c, '<=', \"pes_dummy\"\
  , 11);\n-- INTERVAL DAY TO SECOND\n  PRAGMA interface(c, '=', \"pes_dummy\", 13);\n\
  PRAGMA interface(c, '!=', \"pes_invert\", 13);\nPRAGMA interface(c, '>', \"pes_flip\"\
  , 12);\nPRAGMA interface(c, '<', \"pes_dummy\", 12);\nPRAGMA interface(c, '>=',\
  \ \"pes_flip\", 12);\nPRAGMA interface(c, '<=', \"pes_dummy\", 12);\n-- TIMESTAMP_TZ_UNCONSTRAINED\n\
  \  PRAGMA interface(c, '=', \"pes_dummy\", 14);\nPRAGMA interface(c, '!=', \"pes_invert\"\
  , 14);\nPRAGMA interface(c, '>', \"pes_flip\", 13);\nPRAGMA interface(c, '<', \"\
  pes_dummy\", 13);\nPRAGMA interface(c, '>=', \"pes_flip\", 13);\nPRAGMA interface(c,\
  \ '<=', \"pes_dummy\", 13);\n-- TIMESTAMP WITH LOCAL TIME ZONE\n  PRAGMA interface(c,\
  \ '=', \"pes_dummy\", 15);\nPRAGMA interface(c, '!=', \"pes_invert\", 15);\nPRAGMA\
  \ interface(c, '>', \"pes_flip\", 14);\nPRAGMA interface(c, '<', \"pes_dummy\",\
  \ 14);\nPRAGMA interface(c, '>=', \"pes_flip\", 14);\nPRAGMA interface(c, '<=',\
  \ \"pes_dummy\", 14);\n-- Other datetime functions\n  PRAGMA interface(c, 'CURRENT_DATE',\
  \ \"pescdt\", 1);\nPRAGMA interface(c, 'CURRENT_TIME', \"pesctm\", 1);\nPRAGMA interface(c,\
  \ 'CURRENT_TIMESTAMP', \"pescts\", 1);\n--  Internal calls to evaluate datetime/interval\
  \ literals without NLS parms.\n  PRAGMA interface(c, SYS_LITERALTOYMINTERVAL, \"\
  pesc2ymi\", 1);\nPRAGMA interface(c, SYS_LITERALTODSINTERVAL, \"pesc2dsi\", 1);\n\
  PRAGMA interface(c, SYS_LITERALTOTIME, \"pesc2tim\", 1);\nPRAGMA interface(c, SYS_LITERALTOTZTIME,\
  \ \"pesc2tim\", 1);\nPRAGMA interface(c, SYS_LITERALTOTIMESTAMP, \"pesc2tsp\", 1);\n\
  PRAGMA interface(c, SYS_LITERALTOTZTIMESTAMP, \"pesc2tsp\", 1);\nPRAGMA interface(c,\
  \ SYS_LITERALTODATE, \"pesc2date\", 1);\n-- extract(field from expr)\n  PRAGMA interface(c,\
  \ \" SYS$EXTRACT_FROM\", \"pesefd\", 1);\nPRAGMA interface(c, \" SYS$EXTRACT_FROM\"\
  , \"pesefd\", 2);\nPRAGMA interface(c, \" SYS$EXTRACT_FROM\", \"pesefd\", 3);\n\
  -- ICD #200\n  PRAGMA interface(c, \" SYS$EXTRACT_FROM\", \"pesefd\", 4);\nPRAGMA\
  \ interface(c, \" SYS$EXTRACT_FROM\", \"pesefd\", 5);\nPRAGMA interface(c, \" SYS$EXTRACT_FROM\"\
  , \"pesefdt\", 6);\nPRAGMA interface(c, \" SYS$EXTRACT_FROM\", \"pesefi\", 7);\n\
  PRAGMA interface(c, \" SYS$EXTRACT_FROM\", \"pesefi\", 8);\n-- datetime is null\n\
  \  PRAGMA interface(c, \"IS NULL\", \"pes_dummy\", 14);\n-- time\n  PRAGMA interface(c,\
  \ \"IS NULL\", \"pes_dummy\", 15);\n-- time wtz\n  PRAGMA interface(c, \"IS NULL\"\
  , \"pes_dummy\", 16);\n-- timestamp\n  PRAGMA interface(c, \"IS NULL\", \"pes_dummy\"\
  , 17);\n-- timestamp wtz\n  PRAGMA interface(c, \"IS NULL\", \"pes_dummy\", 18);\n\
  -- timestamp lwtz\n  PRAGMA interface(c, \"IS NULL\", \"pes_dummy\", 19);\n-- interval\
  \ ym\n  PRAGMA interface(c, \"IS NULL\", \"pes_dummy\", 20);\n-- interval ds\n \
  \ -- 8.2 LOB Built-in Functions\n  PRAGMA interface(c, length, \"peslcln\", 2);\n\
  -- LOB LENGTH\n  PRAGMA interface(c, lengthb, \"peslclb\", 2);\n-- LOB LENGTHB\n\
  \  PRAGMA interface(c, substr, \"peslcst\", 2);\n-- LOB SUBSTR\n  PRAGMA interface(c,\
  \ substrb, \"peslcsb\", 2);\n-- LOB SUBSTRB\n  PRAGMA interface(c, instr, \"peslcin\"\
  , 2);\n-- LOB INSTR\n  PRAGMA interface(c, instrb, \"peslcib\", 2);\n-- LOB INSTRB\n\
  \  PRAGMA interface(c, '||', \"peslcct\", 2);\n-- LOB '||'\n  PRAGMA interface(c,\
  \ concat, \"peslcct\", 2);\n-- LOB CONCAT\n  PRAGMA interface(c, lpad, \"peslclp\"\
  , 3);\n-- LOB LPAD\n  PRAGMA interface(c, lpad, \"peslclp\", 4);\n-- LOB LPAD\n\
  \  PRAGMA interface(c, rpad, \"peslcrp\", 3);\n-- LOB RPAD\n  PRAGMA interface(c,\
  \ rpad, \"peslcrp\", 4);\n-- LOB RPAD\n  PRAGMA interface(c, lower, \"peslclr\"\
  , 2);\n-- LOB LOWER\n  PRAGMA interface(c, upper, \"peslcup\", 2);\n-- LOB UPPER\n\
  \  PRAGMA interface(c, ltrim, \"peslclm\", 3);\n-- LOB LTRIM\n  PRAGMA interface(c,\
  \ ltrim, \"peslclm\", 4);\n-- LOB LTRIM\n  PRAGMA interface(c, rtrim, \"peslcrm\"\
  , 3);\n-- LOB RTRIM\n  PRAGMA interface(c, rtrim, \"peslcrm\", 4);\n-- LOB RTRIM\n\
  \  PRAGMA interface(c, trim, \"peslctr\", 2);\n-- LOB TRIM\n  PRAGMA interface(c,\
  \ \" SYS$STANDARD_TRIM\", \"peslctr\", 4);\n-- LOB TRIM\n  PRAGMA interface(c, \"\
  \ SYS$STANDARD_TRIM\", \"peslctr\", 5);\n-- LOB TRIM\n  PRAGMA interface(c, \" SYS$STANDARD_TRIM\"\
  , \"peslctr\", 6);\n-- LOB TRIM\n  PRAGMA interface(c, 'LIKE', \"peslclk\", 3);\n\
  -- LOB LIKE\n  PRAGMA interface(c, 'LIKE', \"peslcl2\", 4);\n-- LOB LIKE\n  PRAGMA\
  \ interface(c, nvl, \"peslcnl\", 17);\n-- LOB NVL\n  PRAGMA interface(c, replace,\
  \ \"peslcrl\", 2);\n-- LOB REPLACE\n  -- LOB Relational Operators\n  -- LHS: CLOB,\
  \    RHS:CLOB\n  PRAGMA interface(c, '=', \"pes_dummy\", 16);\n-- LOB '='\n  PRAGMA\
  \ interface(c, '!=', \"pes_invert\", 16);\n-- LOB '!='\n  PRAGMA interface(c, '>',\
  \ \"pes_flip\", 15);\n-- LOB '>'\n  PRAGMA interface(c, '<', \"pes_dummy\", 15);\n\
  -- LOB '<'\n  PRAGMA interface(c, '>=', \"pes_flip\", 15);\n-- LOB '>='\n  PRAGMA\
  \ interface(c, '<=', \"pes_dummy\", 15);\n-- LOB '<='\n  -- LHS: CLOB,     RHS:VARCHAR2\n\
  \  PRAGMA interface(c, '=', \"pesleq2\", 17);\n-- LOB '='\n  PRAGMA interface(c,\
  \ '!=', \"pes_invert\", 17);\n-- LOB '!='\n  PRAGMA interface(c, '>', \"pes_flip\"\
  , 16);\n-- LOB '>'\n  PRAGMA interface(c, '<', \"pesllt2\", 16);\n-- LOB '<'\n \
  \ PRAGMA interface(c, '>=', \"pes_flip\", 16);\n-- LOB '>='\n  PRAGMA interface(c,\
  \ '<=', \"peslle2\", 16);\n-- LOB '<='  -- ICD #250\n  -- LHS: VARCHAR2, RHS:CLOB\n\
  \  PRAGMA interface(c, '=', \"pes_flip\", 18);\n-- LOB '='\n  PRAGMA interface(c,\
  \ '!=', \"pes_flip\", 18);\n-- LOB '!='\n  PRAGMA interface(c, '>', \"pes_flip\"\
  , 17);\n-- LOB '>'\n  PRAGMA interface(c, '<', \"pesllt3\", 17);\n-- LOB '<'\n \
  \ PRAGMA interface(c, '>=', \"pes_flip\", 17);\n-- LOB '>='\n  PRAGMA interface(c,\
  \ '<=', \"peslle3\", 17);\n-- LOB '<='\n  PRAGMA interface(c, length, \"peslbln\"\
  , 3);\n-- BLOB LENGTH\n  PRAGMA interface(c, lengthb, \"peslblb\", 3);\n-- BLOB\
  \ LENGTHB\n  -- End of 8.2 LOB Built-in Functions\n  PRAGMA interface(c, tz_offset,\
  \ \"pestzo\", 1);\nPRAGMA interface(c, from_tz, \"pesftz\", 1);\nPRAGMA interface(c,\
  \ ISNCHAR, \"pesinc\", 1);\nPRAGMA interface(c, CONVERT, \"pescnv\", 1);\nPRAGMA\
  \ interface(c, CONVERT, \"pescnv\", 2);\nPRAGMA interface(c, CONVERT, \"peslccnv\"\
  , 3);\n-- LOB CONVERT\n  PRAGMA interface(c, CONVERT, \"peslccnv\", 4);\n-- LOB\
  \ CONVERT\n  PRAGMA interface(c, \" SYS$EXTRACT_STRING_FROM\", \"pesefdrvc2\", 1);\n\
  PRAGMA interface(c, \" SYS$EXTRACT_STRING_FROM\", \"pesefdrvc2\", 2);\nPRAGMA interface(c,\
  \ \" SYS$EXTRACT_STRING_FROM\", \"pesefdrvc2\", 3);\nPRAGMA interface(c, TO_CHAR,\
  \ \"pesdtm2c\", 7);\n-- datetime\n  PRAGMA interface(c, TO_CHAR, \"pesdtm2c\", 8);\n\
  PRAGMA interface(c, TO_CHAR, \"pesdtm2c\", 9);\nPRAGMA interface(c, TO_CHAR, \"\
  pesdtm2c\", 10);\nPRAGMA interface(c, TO_CHAR, \"pesdtm2c\", 11);\nPRAGMA interface(c,\
  \ TO_CHAR, \"pesdtm2c\", 12);\nPRAGMA interface(c, TO_CHAR, \"pesdtm2c\", 13);\n\
  PRAGMA interface(c, TO_CHAR, \"pesdtm2c\", 14);\nPRAGMA interface(c, TO_CHAR, \"\
  pesdtm2c\", 15);\nPRAGMA interface(c, TO_CHAR, \"pesdtm2c\", 16);\nPRAGMA interface(c,\
  \ TO_CHAR, \"pesitv2c\", 17);\n-- interval\n  PRAGMA interface(c, TO_CHAR, \"pesitv2c\"\
  , 18);\nPRAGMA interface(c, TO_CHAR, \"pesitv2c\", 19);\nPRAGMA interface(c, TO_CHAR,\
  \ \"pesitv2c\", 20);\n--#### new_names pragmas\n  -- This is an internal pragma\
  \ that restricts the use\n  -- of particular new entries in package standard.\n\
  \  -- It is only valid in package standard.\n  -- Note that left out of the 8.1.5\
  \ set are non datetime\n  -- entries urowid, \"UROWID \", self_is_null and trim.\n\
  \  pragma new_names(\n    '8.1.5',\n    time,\n    \"TIME WITH TIME ZONE\",\n  \
  \  timestamp,\n    \"TIMESTAMP WITH TIME ZONE\",\n    \"INTERVAL DAY TO SECOND\"\
  ,\n    \"INTERVAL YEAR TO MONTH\",\n    to_time,\n    to_timestamp,\n    to_time_tz,\n\
  \    to_timestamp_tz,\n    \" SYS$DSINTERVALSUBTRACT\",\n    \" SYS$YMINTERVALSUBTRACT\"\
  ,\n    to_yminterval,\n    to_dsinterval,\n    NUMTOYMINTERVAL,\n    NUMTODSINTERVAL,\n\
  \    current_date,\n    current_time,\n    current_timestamp\n  );\npragma new_names(\n\
  \    '8.1.6',\n    dbtimezone,\n    sessiontimezone,\n    localtimestamp,\n    localtime,\n\
  \    cube,\n    rollup,\n    grouping,\n    \"TIMESTAMP WITH LOCAL TIME ZONE\"\n\
  \  );\n-- Should there be a 8.2 new names pragma ?\n  -- 8.2 UCS2/UCS4/Complete\
  \ Built-in Functions\n  PRAGMA interface(c, INSTR2, \"pesist2\", 1);\nPRAGMA interface(c,\
  \ INSTR4, \"pesist4\", 1);\nPRAGMA interface(c, INSTRC, \"pesistc\", 1);\nPRAGMA\
  \ interface(c, LENGTH2, \"peslen2\", 1);\nPRAGMA interface(c, LENGTH4, \"peslen4\"\
  , 1);\nPRAGMA interface(c, LENGTHC, \"peslenc\", 1);\nPRAGMA interface(c, LIKE2,\
  \ \"peslik2\", 1);\nPRAGMA interface(c, LIKE2, \"pesli22\", 2);\nPRAGMA interface(c,\
  \ LIKE4, \"peslik4\", 1);\nPRAGMA interface(c, LIKE4, \"pesli42\", 2);\nPRAGMA interface(c,\
  \ LIKEC, \"peslikc\", 1);\nPRAGMA interface(c, LIKEC, \"peslic2\", 2);\nPRAGMA interface(c,\
  \ SUBSTR2, \"pes_dummy\", 1);\nPRAGMA interface(c, SUBSTR4, \"pes_dummy\", 1);\n\
  PRAGMA interface(c, SUBSTRC, \"pes_dummy\", 1);\nPRAGMA interface(c, SYS_EXTRACT_UTC,\
  \ \"pessexu\");\nPRAGMA interface(c, COMPOSE, \"pescomp\");\nPRAGMA interface(c,\
  \ DECOMPOSE, \"pesdcmp\");\n-- End of 8.2 UCS2/UCS4/Complete Built-in Functions\n\
  \  -- Begin REGEXP support (10iR1) --\n  PRAGMA interface(c, regexp_like, \"pes_dummy\"\
  , 1);\nPRAGMA interface(c, regexp_instr, \"pes_dummy\", 1);\n-- ICD #300\n  PRAGMA\
  \ interface(c, regexp_substr, \"pes_dummy\", 1);\nPRAGMA interface(c, regexp_replace,\
  \ \"pes_dummy\", 1);\nPRAGMA interface(c, regexp_count, \"pes_dummy\", 1);\nPRAGMA\
  \ interface(c, regexp_like, \"pes_dummy\", 2);\n-- LOB REGEXP_LIKE\n  PRAGMA interface(c,\
  \ regexp_instr, \"pes_dummy\", 2);\n-- LOB REGEXP_INSTR\n  PRAGMA interface(c, regexp_substr,\
  \ \"pes_dummy\", 2);\n-- LOB REGEXP_SUBSTR\n  PRAGMA interface(c, regexp_replace,\
  \ \"pes_dummy\", 2);\n-- LOB REGEXP_REPLACE\n  PRAGMA interface(c, regexp_count,\
  \ \"pes_dummy\", 2);\n-- LOB REGEXP_COUNT\n  PRAGMA interface(c, regexp_replace,\
  \ \"pes_dummy\", 3);\n-- LOB REGEXP_REPLACE\n  -- End of REGEXP Built-in Functions\
  \ --\n  -- 10i Binary Floating-point Built-in Functions\n  PRAGMA interface(c, \"\
  IS NAN\", \"pesnanf\", 2);\nPRAGMA interface(c, \"IS NAN\", \"pesnand\", 3);\nPRAGMA\
  \ interface(c, \"IS INFINITE\", \"pesinf\", 1);\nPRAGMA interface(c, \"IS INFINITE\"\
  , \"pesinff\", 2);\nPRAGMA interface(c, \"IS INFINITE\", \"pesinfd\", 3);\nPRAGMA\
  \ interface(c, TO_BINARY_FLOAT, \"pesc2flt\", 2);\nPRAGMA interface(c, TO_BINARY_FLOAT,\
  \ \"pesc2flt\", 3);\nPRAGMA interface(c, TO_BINARY_DOUBLE, \"pesc2dbl\", 2);\nPRAGMA\
  \ interface(c, TO_BINARY_DOUBLE, \"pesc2dbl\", 3);\nPRAGMA interface(c, TO_CHAR,\
  \ \"pesflt2c\", 21);\nPRAGMA interface(c, TO_CHAR, \"pesdbl2c\", 22);\nPRAGMA interface(c,\
  \ TO_CHAR, \"pesflt2c\", 23);\nPRAGMA interface(c, TO_CHAR, \"pesdbl2c\", 24);\n\
  PRAGMA interface(c, TO_NCHAR, \"pesflt2c\", 6);\nPRAGMA interface(c, TO_NCHAR, \"\
  pesdbl2c\", 7);\nPRAGMA interface(c, TO_NCHAR, \"pesflt2c\", 8);\nPRAGMA interface(c,\
  \ TO_NCHAR, \"pesdbl2c\", 9);\nPRAGMA interface(c, 'REMAINDER', \"pesrem\", 1);\n\
  PRAGMA interface(c, REMAINDER, \"pesrem\", 2);\nPRAGMA interface(c, 'REMAINDER',\
  \ \"pesremf\", 3);\nPRAGMA interface(c, REMAINDER, \"pesremf\", 4);\nPRAGMA interface(c,\
  \ 'REMAINDER', \"pesremd\", 5);\nPRAGMA interface(c, REMAINDER, \"pesremd\", 6);\n\
  PRAGMA interface(c, ABS, \"pes_dummy\", 2);\nPRAGMA interface(c, ABS, \"pes_dummy\"\
  , 3);\nPRAGMA interface(c, ABS, \"pes_dummy\", 4);\nPRAGMA interface(c, ATAN, \"\
  pesatand\", 2);\nPRAGMA interface(c, 'MOD', \"pesmodf\", 2);\nPRAGMA interface(c,\
  \ 'MOD', \"pesmodd\", 3);\nPRAGMA interface(c, floor, \"pesflof\", 2);\nPRAGMA interface(c,\
  \ floor, \"pesflod\", 3);\nPRAGMA interface(c, CEIL, \"pesceif\", 2);\nPRAGMA interface(c,\
  \ CEIL, \"pesceid\", 3);\nPRAGMA interface (c, SQRT, \"pessqtf\", 2);\nPRAGMA interface\
  \ (c, SQRT, \"pessqtd\", 3);\nPRAGMA interface(c, SIGN, \"pessgnf\", 2);\nPRAGMA\
  \ interface(c, SIGN, \"pessgnd\", 3);\nPRAGMA interface(c, SIGN, \"pessgni\", 4);\n\
  PRAGMA interface(c, cos, \"pescosd\", 2);\nPRAGMA interface(c, sin, \"pessind\"\
  , 2);\nPRAGMA interface(c, TAN, \"pestand\", 2);\nPRAGMA interface(c, COSH, \"pescshd\"\
  , 2);\nPRAGMA interface(c, SINH, \"pessnhd\", 2);\n-- ICD #350\n  PRAGMA interface(c,\
  \ TANH, \"pestnhd\", 2);\nPRAGMA interface(c, EXP, \"pesexpd\", 2);\nPRAGMA interface(c,\
  \ LN, \"peslnd\", 2);\nPRAGMA interface(c, LOG, \"peslogd\", 2);\nPRAGMA interface(c,\
  \ TRUNC, \"pestruf\", 4);\nPRAGMA interface(c, TRUNC, \"pestrud\", 5);\nPRAGMA interface(c,\
  \ TRUNC, \"pestrui\", 6);\nPRAGMA interface(c, ROUND, \"pesrndf\", 4);\nPRAGMA interface(c,\
  \ ROUND, \"pesrndd\", 5);\nPRAGMA interface(c, ROUND, \"pesrndi\", 6);\nPRAGMA interface(c,\
  \ POWER, \"pespowd\", 2);\n-- End of 10i Binary Floating-point Built-in Functions\n\
  \  -- ICDs for MULTISET\n  PRAGMA interface(c, CARDINALITY, \"pesmcnt\");\nPRAGMA\
  \ interface(c, \"IS EMPTY\", \"pesmie\");\nPRAGMA interface(c, \"IS NOT EMPTY\"\
  , \"pes_invert\", 1);\n-- ICDs which used to be in the body of standard, but which\
  \ new COG can\n  -- handle directly\n  -- NOT (some ICD)\n  PRAGMA interface(c,\
  \ NOT_LIKE, \"pes_invert\", 1);\nPRAGMA interface(c, NOT_LIKE, \"pes_invert\", 2);\n\
  PRAGMA interface(c, NOT_LIKE, \"pes_invert\", 3);\nPRAGMA interface(c, NOT_LIKE,\
  \ \"pes_invert\", 4);\nPRAGMA interface(c, NOT_LIKE2, \"pes_invert\", 1);\nPRAGMA\
  \ interface(c, NOT_LIKE2, \"pes_invert\", 2);\nPRAGMA interface(c, NOT_LIKE4, \"\
  pes_invert\", 1);\nPRAGMA interface(c, NOT_LIKE4, \"pes_invert\", 2);\nPRAGMA interface(c,\
  \ NOT_LIKEC, \"pes_invert\", 1);\nPRAGMA interface(c, NOT_LIKEC, \"pes_invert\"\
  , 2);\nPRAGMA interface(c, \"IS NOT NAN\", \"pes_invert\", 2);\nPRAGMA interface(c,\
  \ \"IS NOT NAN\", \"pes_invert\", 3);\nPRAGMA interface(c, \"IS NOT INFINITE\",\
  \ \"pes_invert\", 1);\nPRAGMA interface(c, \"IS NOT INFINITE\", \"pes_invert\",\
  \ 2);\nPRAGMA interface(c, \"IS NOT INFINITE\", \"pes_invert\", 3);\n-- datetime\
  \ is not null\n  PRAGMA interface(c, \"IS NOT NULL\", \"pes_dummy\", 14);\n-- time\n\
  \  PRAGMA interface(c, \"IS NOT NULL\", \"pes_dummy\", 15);\n-- time wtz\n  PRAGMA\
  \ interface(c, \"IS NOT NULL\", \"pes_dummy\", 16);\n-- timestamp\n  PRAGMA interface(c,\
  \ \"IS NOT NULL\", \"pes_dummy\", 17);\n-- timestamp wtz\n  PRAGMA interface(c,\
  \ \"IS NOT NULL\", \"pes_dummy\", 18);\n-- timestamp lwtz\n  PRAGMA interface(c,\
  \ \"IS NOT NULL\", \"pes_dummy\", 19);\n-- interval ym\n  PRAGMA interface(c, \"\
  IS NOT NULL\", \"pes_dummy\", 20);\n-- interval ds\n  -- Misc\n  PRAGMA interface(c,\
  \ \"**\", \"pespow\", 1);\n-- number\n  PRAGMA interface(c, \"**\", \"pespowd\"\
  , 2);\n-- binary double\n  PRAGMA interface(c, \"ACOS\", \"pesacosd\", 2);\n-- binary\
  \ double\n  PRAGMA interface(c, \"ASIN\", \"pesasind\", 2);\n-- binary double\n\
  \  PRAGMA interface(c, \"ATAN2\", \"pesatn2d\", 2);\n-- binary double\n  -- All\
  \ the flavors of NVL\n  PRAGMA interface(c, nvl, \"pes_dummy\", 1);\n-- Boolean\
  \ -- ICD #400\n  PRAGMA interface(c, nvl, \"pes_dummy\", 2);\n-- Varchar2\n  PRAGMA\
  \ interface(c, nvl, \"pes_dummy\", 3);\n-- Number\n  PRAGMA interface(c, nvl, \"\
  pes_dummy\", 4);\n-- Date\n  PRAGMA interface(c, nvl, \"pes_dummy\", 5);\n-- MLSLabel\n\
  \  PRAGMA interface(c, nvl, \"pes_dummy\", 6);\n-- ADT\n  PRAGMA interface(c, nvl,\
  \ \"pes_dummy\", 7);\n-- Ref ADT\n  PRAGMA interface(c, nvl, \"pes_dummy\", 8);\n\
  -- Collection\n  --  Ref Cursor has problems. The MOVCR instruction needs more information\
  \ than\n  --  the other MOV* instructions, including the PVM register of the destination\n\
  \  --  This cannot be easily supplied through the generic NVL instruction, so\n\
  \  --  for now, this flavor will continue to have a real body\n  --  PRAGMA interface(c,nvl,\"\
  pes_dummy\",9);       -- Ref Cursor\n  PRAGMA interface(c, nvl, \"pes_dummy\", 10);\n\
  -- Time\n  PRAGMA interface(c, nvl, \"pes_dummy\", 11);\n-- Time-tz\n  PRAGMA interface(c,\
  \ nvl, \"pes_dummy\", 12);\n-- Timestamp\n  PRAGMA interface(c, nvl, \"pes_dummy\"\
  , 13);\n-- Timestamp-tz\n  PRAGMA interface(c, nvl, \"pes_dummy\", 14);\n-- Timestamp-ltz\n\
  \  PRAGMA interface(c, nvl, \"pes_dummy\", 15);\n-- Intervalym\n  PRAGMA interface(c,\
  \ nvl, \"pes_dummy\", 16);\n-- Intervalds\n  --  PRAGMA interface(c,nvl,\"pes_dummy\"\
  ,17);       -- Clob (Handled above, ICD)\n  PRAGMA interface(c, nvl, \"pes_dummy\"\
  , 18);\n-- Opaque\n  PRAGMA interface(c, nvl, \"pes_dummy\", 19);\n-- Binaryfloat\n\
  \  PRAGMA interface(c, nvl, \"pes_dummy\", 20);\n-- Binarydouble\n  PRAGMA interface(c,\
  \ nvl, \"pes_dummy\", 21);\n-- PLSInteger\n  -- The following pragma overrides any\
  \ other setting of the timestamp,\n  -- and is used so that we recognize the client-side\
  \ and server-side instances\n  -- of package STANDARD as being the same.  Package\
  \ STANDARD is special in\n  -- that it is really the root of the PL/SQL dependencies\
  \ graph; as such it\n  -- itself doesn't ever need recompiling due to changes to\
  \ things below it.\n  -- The pragma mechanism used here is currently ignored except\
  \ for\n  -- package STANDARD, but in future may not be.  Do NOT add similar pragmas\n\
  \  -- to your own code as it may in future interfere with the package\n  -- consistency\
  \ maintenance mechanisms and could have dire results.\n  --#### timestamp pragma\
  \ (please keep this last)\n  pragma TIMESTAMP('2006-04-18:00:00:00');\nend;"
